package com.mercurio.lms.contasreceber.report;

import java.util.HashMap;
import java.util.Map;

import net.sf.jasperreports.engine.JRDataSource;

import com.mercurio.adsm.framework.report.JRReportDataObject;
import com.mercurio.adsm.framework.report.ReportServiceSupport;
import com.mercurio.adsm.framework.util.SqlTemplate;
import com.mercurio.lms.util.session.SessionUtils;

/**
 * Generated by: ADSM ActionGenerator
 *  
 * Não inserir documentação após ou remover a tag do XDoclet a seguir.
 * O valor do <code>id</code> informado abaixo deve ser utilizado para referenciar este serviço.
 * @spring.bean id="lms.contasreceber.emitirChequesPreDatadosTransferenciaMatrizService"
 * @spring.property name="reportName" value="com/mercurio/lms/contasreceber/report/emitirChequesPreDatadosTransferenciaMatriz.jasper"
 */

public class EmitirChequesPreDatadosTransferenciaMatrizService extends ReportServiceSupport {

	/**
	 * método responsável por gerar o relatório. 
	 */
	public JRReportDataObject execute(Map parameters) throws Exception {

		SqlTemplate sql = new SqlTemplate(); 

		sql.setDistinct();
		
		sql.addProjection(" lc.id_lote_cheque, lc.nr_lote_cheque ");
		
		sql.addFrom(new StringBuffer()
				.append("  cheque c " +
						"  INNER JOIN lote_cheque lc on lc.id_lote_cheque = c.id_lote_cheque " +
						"  INNER JOIN moeda ml on ml.id_moeda = lc.id_moeda " +
						"  LEFT  JOIN redeco r on r.id_redeco = lc.id_redeco " +
						"  INNER JOIN moeda_pais mp on mp.id_moeda_pais = c.id_moeda_pais " +
						"  INNER JOIN moeda m on m.id_moeda = mp.id_moeda " +
						"  INNER JOIN filial f on f.id_filial = c.id_filial " +
						"  INNER JOIN pessoa pf on pf.id_pessoa = f.id_filial " +
						"  LEFT  JOIN cliente cli on cli.id_cliente = c.id_cliente " +
						"  LEFT  JOIN pessoa pc on pc.id_pessoa = cli.id_cliente " +
						"  INNER JOIN historico_cheque hc on hc.id_cheque = c.id_cheque " +
						"         AND hc.tp_historico_cheque = 'TM' " + 
						"         AND hc.id_historico_cheque = (SELECT max(id_historico_cheque) " +
				        "                             			FROM   historico_cheque hc2 " +
				        "                             			WHERE  hc2.id_cheque = c.id_cheque) ") +
				        "  AND c.id_filial = " + (SessionUtils.getFilialSessao().getIdFilial() )
				.toString()
		);
		
		if (parameters.get("loteCheque.idLoteCheque") != null && !parameters.get("loteCheque.idLoteCheque").equals(""))
			  sql.addCriteria("lc.ID_LOTE_CHEQUE", "=", parameters.get("loteCheque.idLoteCheque").toString() ); 

		if (parameters.get("redeco.idRedeco") != null && !parameters.get("redeco.idRedeco").equals(""))
		  sql.addCriteria("lc.ID_REDECO", "=", parameters.get("redeco.idRedeco").toString() ); 
		
		sql.addOrderBy("lc.NR_LOTE_CHEQUE");
		
		JRReportDataObject jr = executeQuery(sql.getSql(), sql.getCriteria());

		Map parametersReport = new HashMap();
        parametersReport.put(JRReportDataObject.EXPORT_MODE_PARAM, parameters.get("tpFormatoRelatorio"));
        jr.setParameters(parametersReport);
		
		return jr;
	}
	
	public JRDataSource executeSubReport(Object[] parameters) throws Exception {
		String sql = getSqlSub(parameters);
		return executeQuery(sql, new Object[] {}).getDataSource();
	}
	
	private String getSqlSub(Object[] parameters) {
		
		StringBuffer sql = new StringBuffer();
		
		sql.append("SELECT lc.nr_lote_cheque as numero, " +
						"  lc.dt_emissao as emissao, " +
						"  f.sg_filial || ' - ' || pf.nm_fantasia as filial, " +
						"  (SELECT ds_conteudo FROM parametro_geral WHERE nm_parametro_geral LIKE 'DS_CONTA_CONTABIL_CHEQUE') as debito, " +
						"  (fr.sg_filial || ' ' || to_char(r.nr_redeco, '0000000000')) as redeco, " +
						"  nr_cheque as nr_cheque, " +
						"  nr_banco as banco, " +
						"  c.NM_RESPONSAVEL as cliente, " +
						"  c.dt_vencimento as vencimento, " +
						"  m.sg_moeda || ' ' || m.ds_simbolo as sigla_simbolo, " +
						"  c.vl_cheque as valor, " +
						"  ml.sg_moeda || ' ' || ml.ds_simbolo as moeda_sessao, " +
						"  lc.vl_total_lote as vl_total_lote " +
						"  FROM  cheque c " +
						"  INNER JOIN lote_cheque lc on lc.id_lote_cheque = c.id_lote_cheque " +
						"  INNER JOIN moeda ml on ml.id_moeda = lc.id_moeda " +
						"  LEFT  JOIN redeco r on r.id_redeco = lc.id_redeco " +
						"  LEFT JOIN filial fr on fr.id_filial = r.id_filial " +
						"  INNER JOIN moeda_pais mp on mp.id_moeda_pais = c.id_moeda_pais " +
						"  INNER JOIN moeda m on m.id_moeda = mp.id_moeda " +
						"  INNER JOIN filial f on f.id_filial = c.id_filial " +
						"  INNER JOIN pessoa pf on pf.id_pessoa = f.id_filial " +
						"  LEFT  JOIN cliente cli on cli.id_cliente = c.id_cliente " +
						"  LEFT  JOIN pessoa pc on pc.id_pessoa = cli.id_cliente " +
						"  INNER JOIN historico_cheque hc on hc.id_cheque = c.id_cheque " +
						"         AND hc.tp_historico_cheque = 'TM' " + 
						"         AND hc.id_historico_cheque = (SELECT max(id_historico_cheque) " +
				        "                             			FROM   historico_cheque hc2 " +
				        "                             			WHERE  hc2.id_cheque = c.id_cheque) " +
						"  WHERE 0 = 0 "
		);
						
		sql.append("  AND c.id_filial = " + SessionUtils.getFilialSessao().getIdFilial() ); 

		sql.append("  AND lc.id_lote_cheque = " + parameters[0] ); 

		/* GAMBIARRA: os resultsets da 1a e 2a via eram fechados pois o sql era sempre igual, assim imprimia somente a 3a via */
		long i = System.currentTimeMillis();
		sql.append("  AND " + i + " = " + i );

		sql.append(" ORDER BY lc.nr_lote_cheque, c.nr_cheque, c.nr_banco, pc.nm_pessoa");
		
		return sql.toString();
	}
	
}