package com.mercurio.lms.municipios.report;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;

import net.sf.jasperreports.engine.JRDataSource;
import net.sf.jasperreports.engine.data.JRMapCollectionDataSource;

import org.springframework.jdbc.core.JdbcTemplate;

import com.mercurio.adsm.framework.model.DomainValue;
import com.mercurio.adsm.framework.model.JodaTimeUtils;
import com.mercurio.adsm.framework.model.service.DomainValueService;
import com.mercurio.adsm.framework.report.JRReportDataObject;
import com.mercurio.adsm.framework.report.ReportServiceSupport;
import com.mercurio.adsm.framework.session.SessionContext;
import com.mercurio.adsm.framework.util.SqlTemplate;
import com.mercurio.adsm.framework.util.TypedFlatMap;
import com.mercurio.lms.municipios.model.TipoPagamentoPosto;
import com.mercurio.lms.municipios.model.dao.TipoPagamentoPostoDAO;
import com.mercurio.lms.municipios.model.service.PostoPassagemService;
import com.mercurio.lms.util.JTDateTimeUtils;
/**
 * Generated by: ADSM ActionGenerator
 *  
 * Não inserir documentação após ou remover a tag do XDoclet a seguir.
 * O valor do <code>id</code> informado abaixo deve ser utilizado para referenciar este serviço.
 * @spring.bean id="lms.municipios.report.emitirPostosPassagemRotaColetaEntregaService"
 * 
 * @spring.property name="reportName" value="/com/mercurio/lms/municipios/report/EmitirPostosPassagemRotaCE.vm"
 *
 * @spring.property name="numberOfCrosstabs" value="1"
 * @spring.property name="crossTabLefts" value="253"
 * @spring.property name="crossTabBandWidths" value="533"
 * @spring.property name="numbersOfCrossTabColumns" value="11"
 * 
 */	 
public class EmitirPostosPassagemRotaColetaEntregaService extends ReportServiceSupport {

	private DomainValueService domainValueService;
	private PostoPassagemService postoPassagemService;
	private TipoPagamentoPostoDAO tipoPagamentoPostoDAO;
	
	/* Nome da Tebela temporaria */
	private static final String NOME_TABELA = "TMP_POSTOPASSAGEM";	
	
	/* Definição das colunas de header. */
	private ColumnsDefinition columnsDefinition;
	
	/* Inner Class utilizada para a definição de uma coluna */
	private class ColumnsDefinition
	{
		
		private int totColumns;
		private Set columns = new LinkedHashSet();
		private String sqlNameColumns;
		private HashMap tabela;
		private List registros;
		
		public ColumnsDefinition(){}
		
		public ColumnsDefinition(int totColumns, Set columns, String sqlNameColumns,List registros) {
			this.totColumns = totColumns;
			this.columns = columns;
			this.sqlNameColumns = sqlNameColumns;
			this.registros = registros;
		}
		
		public List getRegistros() {
			return registros;
		}

		public void setRegistros(List registros) {
			this.registros = registros;
		}

		
		public Set getColumns() {
			return columns;
		}

		public void setColumns(Set columns) {
			this.columns = columns;
		}

		public String getSqlNameColumns() {
			return sqlNameColumns;
		}

		public void setSqlNameColumns(String sqlNameColumns) {
			this.sqlNameColumns = sqlNameColumns;
		}

		public int getTotColumns() {
			return totColumns;
		}

		public void setTotColumns(int totColumns) {
			this.totColumns = totColumns;
		}

		public HashMap getTabela() {
			return tabela;
		}

		public void setTabela(HashMap tabela) {
			this.tabela = tabela;
		}		
		
	}
	
	/* Metodo que obtem as definições das colunas */
	private ColumnsDefinition getColumns(List listDados, Long idMoedaPais)
	{
		Set setCrosstab = new LinkedHashSet();	
		
		Map mapIdRotas = new HashMap();
								
		HashMap tabelas = new HashMap();
		
		List registros = new ArrayList();
		
		
		String names = "";
		
		int i = 0;
		
		//******************************headers dinamicos***********************************************
		/* Descobre as Colunas(Headers) do relatorio.*/ 
		for (Iterator it1 = listDados.iterator(); it1.hasNext();) { 
			Map map = (Map)it1.next();
			String dsTipoMeioTransporte = (String)map.get("DS_TIPO_MEIO_TRANSPORTE");
			setCrosstab.add(dsTipoMeioTransporte);	
		}
		//coloca as colunas num array
		Object[]lista = setCrosstab.toArray();	
		
		
		HashMap mapPagamentoPorRota = null;
		
		
		//***********************************manipulação dos dados******************************************
		/* Descobre as Colunas(Headers) do relatorio. */
		for (Iterator it = listDados.iterator(); it.hasNext(); i++) { 
			Map map = (Map)it.next();
			//parametros para encontrar o valor do pedagio
			Long idPostoPassagem = Long.valueOf(map.get("ID_POSTO_PASSAGEM").toString());
			Long idTipoMeioTransporte = Long.valueOf(map.get("ID_TIPO_MEIO_TRANSPORTE").toString());
			Integer qtEixos = Integer.valueOf(map.get("QT_EIXOS").toString());
			 
			//metodo que encontra o valor do pedagio e o tipo de pagamento do pedagio
			TypedFlatMap typedFlatMap = postoPassagemService.findVlByTpMeioTransporte(idPostoPassagem,idTipoMeioTransporte,qtEixos,JTDateTimeUtils.getDataAtual(),idMoedaPais, false);
			
			BigDecimal vlTarifa = typedFlatMap.getBigDecimal("vlPostoPassagem");
			Long idTipoPagamentoPosto = typedFlatMap.getLong("idTipoPagamentoPosto");
			TipoPagamentoPosto tipoPagamentoPosto = (TipoPagamentoPosto)tipoPagamentoPostoDAO.getAdsmHibernateTemplate().load(TipoPagamentoPosto.class,idTipoPagamentoPosto);
						
			Object idRotaColetaEntrega =map.get("ID_ROTA_COLETA_ENTREGA");
			String dsTipoPagamPostoPassagem = tipoPagamentoPosto.getTipoPagamPostoPassagem().getDsTipoPagamPostoPassagem().toString();
			Object idFilial = map.get("ID_FILIAL");
			String nmMunicipio = (String)map.get("NM_MUNICIPIO");
			String dsTipoMeioTransporte = (String)map.get("DS_TIPO_MEIO_TRANSPORTE");
					
			
			
			
			//AGRUPAMENTO ROTA
			if(!mapIdRotas.containsKey(idRotaColetaEntrega)){
				//verifica os dados da última rota inserida a adiciona os totalizadores na lista, após todos os registros
				if(mapPagamentoPorRota != null){
					Object idFilialTotal = null;
					Object idRotaColetaEntregaTotal = null;
					String sgFilial = "";
					String nmFilial = "";
					String dsRota = "";
					
					if(registros != null){
						int total = registros.size();
						Map mapRegistro = (Map)registros.get(total-1);
						idRotaColetaEntregaTotal = mapRegistro.get("idRotaColetaEntrega");
						idFilialTotal = mapRegistro.get("idFilial");
						sgFilial = mapRegistro.get("sgFilial").toString();
						nmFilial = mapRegistro.get("nmFilial").toString();
						dsRota = mapRegistro.get("dsRota").toString();
					}
					Object[] listaTotalizadora =new Object[setCrosstab.size()];
					
					int m=0;
					//coloca na listaGeral cada totalizador de pagamento
					for(Iterator chaves = mapPagamentoPorRota.keySet().iterator(); chaves.hasNext();m++) {
						String chave =(String) chaves.next();
						Object[] pagamentos = (Object[])mapPagamentoPorRota.get(chave);
																		
						for(int pos1=0;pos1<pagamentos.length;pos1++){
							BigDecimal valorNovo =(BigDecimal)pagamentos[pos1];
							BigDecimal valorExistente = new BigDecimal(0);
							if(listaTotalizadora[pos1]!= null){
								valorExistente = (BigDecimal)listaTotalizadora[pos1];
								BigDecimal totalPorMeioTransporte = valorExistente.add(valorNovo);
								listaTotalizadora[pos1]= totalPorMeioTransporte;
							}else{
								valorExistente = valorExistente.add(valorNovo);
								listaTotalizadora[pos1]= valorExistente;
							}
							
						}
												
						Map mapTransferencia = new HashMap();
						mapTransferencia.put("sgFilial",sgFilial);
						mapTransferencia.put("nmFilial",nmFilial);
						mapTransferencia.put("dsRota",dsRota);
						mapTransferencia.put("tpPostoPassagem","");
						mapTransferencia.put("nmMunicipio","");
						mapTransferencia.put("sgUnidadeFederativa","");
						mapTransferencia.put("nmPais","");
						mapTransferencia.put("tpSentidoCobranca","");
						mapTransferencia.put("tpFormaCobranca",chave);
						mapTransferencia.put("idRotaColetaEntrega",idRotaColetaEntregaTotal);
						mapTransferencia.put("idFilial",idFilialTotal);
						mapTransferencia.put("dsRodovia","");
						mapTransferencia.put("sgRodovia","");
						mapTransferencia.put("nrKm",null);
						mapTransferencia.put("nomeConcessionaria","");
						
						if(m==0)
							mapTransferencia.put("totalizador","P");
						else 
							mapTransferencia.put("totalizador","T");
						
						mapTransferencia.put(chave,pagamentos);
						
						registros.add(mapTransferencia);
					}
					//coloca na list os totalizadores de cada rota por meio de transporte
					Map mapTotal = new  HashMap();
					mapTotal.put("sgFilial",sgFilial);
					mapTotal.put("nmFilial",nmFilial);
					mapTotal.put("dsRota",dsRota);
					mapTotal.put("tpPostoPassagem","");
					mapTotal.put("nmMunicipio","");
					mapTotal.put("sgUnidadeFederativa","");
					mapTotal.put("nmPais","");
					mapTotal.put("tpSentidoCobranca","");
					mapTotal.put("tpFormaCobranca","Total");
					mapTotal.put("idRotaColetaEntrega",idRotaColetaEntregaTotal);
					mapTotal.put("idFilial",idFilialTotal);
					mapTotal.put("dsRodovia","");
					mapTotal.put("sgRodovia","");
					mapTotal.put("nrKm",null);
					mapTotal.put("nomeConcessionaria","");
					mapTotal.put("totalizador","T");
					mapTotal.put("Total",listaTotalizadora);
					registros.add(mapTotal);
			  }	//fim da rota
				
				//nova rota
				mapIdRotas.put(idRotaColetaEntrega, null);
				mapPagamentoPorRota = new HashMap();
				
			}
			//FIM ROTA
			
			
			//AGRUPAMENTO POSTO DE PASSAGEM
			//verifica se no map consta o municipio, se nao consta cria um array para colocar os valores do pedagio daquele municipio
			String nmMunicipioRota = nmMunicipio+idRotaColetaEntrega.toString()+idPostoPassagem.toString();
			if (!tabelas.containsKey(nmMunicipioRota) || mapPagamentoPorRota.isEmpty()) 
			{
				//cria o array para cada municipio e um array para cada totalizador e inicia o array com os valores 0
				tabelas.put(nmMunicipioRota, new Object[setCrosstab.size()]);
				
				//se for um novo tipo de pagamento para a rota
				if(!mapPagamentoPorRota.containsKey(dsTipoPagamPostoPassagem)){
					mapPagamentoPorRota.put(dsTipoPagamPostoPassagem,new Object[setCrosstab.size()]);
					
				}
				
												
				//Registro
			
				String sgFilial = (String)map.get("SG_FILIAL");
				String nmFilial = (String)map.get("NM_FILIAL");
				Object nrRota = map.get("NR_ROTA");
				String dsRota = nrRota.toString()+" - "+(String)map.get("DS_ROTA");
				
				DomainValue tpPostoPassagem = domainValueService.findDomainValueByValue("DM_POSTO_PASSAGEM",(String)map.get("TP_POSTO_PASSAGEM"));
				
				String sgRodovia = (String)map.get("SG_RODOVIA");
				String dsRodovia = (String)map.get("DS_RODOVIA");
				Object nrKm = map.get("NR_KM");
				DomainValue tpSentidoCobranca = domainValueService.findDomainValueByValue("DM_SENTIDO_COBRANCA_POSTO_PASSAGEM",(String)map.get("TP_SENTIDO_COBRANCA"));
			
				DomainValue tpFormaCobranca = domainValueService.findDomainValueByValue("DM_FORMA_COBRANCA_POSTO_PASSAGEM",(String)map.get("TP_FORMA_COBRANCA"));
								
				HashMap linha = new HashMap();
				HashMap valoresFixos = new HashMap();
								
				valoresFixos.put("idFilial",idFilial);
				valoresFixos.put("sgFilial",sgFilial);
				valoresFixos.put("nmFilial",nmFilial);
				valoresFixos.put("dsRota",dsRota);
				valoresFixos.put("tpPostoPassagem",tpPostoPassagem.getValue());
				valoresFixos.put("nmMunicipio",nmMunicipio);
				valoresFixos.put("sgUnidadeFederativa","");
				valoresFixos.put("nmPais","");
				valoresFixos.put("sgRodovia",sgRodovia);
				valoresFixos.put("dsRodovia",dsRodovia);
				valoresFixos.put("nrKm",nrKm);
				valoresFixos.put("tpSentidoCobranca",tpSentidoCobranca.getValue());
				valoresFixos.put("nomeConcessionaria","");
				valoresFixos.put("tpFormaCobranca",tpFormaCobranca.getValue());
				valoresFixos.put("idRotaColetaEntrega",idRotaColetaEntrega);
				valoresFixos.put("idPostoPassagem",idPostoPassagem);
								
				linha.putAll(valoresFixos);
				
				registros.add(linha);
			}
			
			//FIM POSTO PASSAGEM
			
			//TIPOS DE PAGAMENTO
			for(int mz =0; mz<setCrosstab.size(); mz++){
				Object[] municipios = ((Object[])tabelas.get(nmMunicipioRota));
			    Object[] pagamentosPorRota = (Object[])mapPagamentoPorRota.get(dsTipoPagamPostoPassagem);
			    if(lista[mz].equals(dsTipoMeioTransporte)){
					municipios[mz]= vlTarifa;
					BigDecimal valorNovo = vlTarifa;
					BigDecimal valorExistente = new BigDecimal(0);
					if(pagamentosPorRota[mz] != null){
					   valorExistente = (BigDecimal)pagamentosPorRota[mz];
					}
					BigDecimal total = valorNovo.add(valorExistente);
					pagamentosPorRota[mz]=total;
					
					break;
				}
			}
			
			//no caso de ser o ultimo registro
			if(i+1==listDados.size()){
				Object[] listaTotalizadora = new Object[setCrosstab.size()];
				if(mapPagamentoPorRota != null){
					Object idFilialTotal = null;
					Object idRotaColetaEntregaTotal = null;
					String sgFilial = "";
					String nmFilial = "";
					String dsRota = "";
					if(registros != null){
						int total = registros.size();
						Map mapRegistro = (Map)registros.get(total-1);
						idRotaColetaEntregaTotal = mapRegistro.get("idRotaColetaEntrega");
						idFilialTotal = mapRegistro.get("idFilial");
						sgFilial = mapRegistro.get("sgFilial").toString();
						nmFilial = mapRegistro.get("nmFilial").toString();
						dsRota =mapRegistro.get("dsRota").toString();
					}
					int n =0;
					for(Iterator chaves = mapPagamentoPorRota.keySet().iterator(); chaves.hasNext();n++) {
						String chave =(String) chaves.next();
						Object[] pagamentos = (Object[])mapPagamentoPorRota.get(chave);
						
						for(int pos=0;pos<pagamentos.length;pos++){
							BigDecimal valorNovo =(BigDecimal)pagamentos[pos];
							BigDecimal valorExistente = new BigDecimal(0);
							if(listaTotalizadora[pos]!= null)
							    valorExistente = (BigDecimal)listaTotalizadora[pos];
							BigDecimal totalPorMeioTransporte = valorExistente.add(valorNovo);
							listaTotalizadora[pos] = totalPorMeioTransporte;
						}
						Map mapTransferencia = new HashMap();
						mapTransferencia.put("sgFilial",sgFilial);
						mapTransferencia.put("nmFilial",nmFilial);
						mapTransferencia.put("dsRota",dsRota);
						mapTransferencia.put("tpPostoPassagem","");
						mapTransferencia.put("nmMunicipio","");
						mapTransferencia.put("sgUnidadeFederativa","");
						mapTransferencia.put("nmPais","");
						mapTransferencia.put("tpSentidoCobranca","");
						mapTransferencia.put("tpFormaCobranca",chave);
						mapTransferencia.put("idRotaColetaEntrega",idRotaColetaEntregaTotal);
						mapTransferencia.put("idFilial",idFilialTotal);
						mapTransferencia.put("dsRodovia","");
						mapTransferencia.put("sgRodovia","");
						mapTransferencia.put("nrKm",null);
						mapTransferencia.put("nomeConcessionaria","");
						if(n==0)
						mapTransferencia.put("totalizador","P");
						else
							mapTransferencia.put("totalizador","T");
						
						
						mapTransferencia.put(chave,pagamentos);
						registros.add(mapTransferencia);
					}
					//coloca na list os totalizadores de cada rota
					Map mapTotal = new  HashMap();
					mapTotal.put("sgFilial",sgFilial);
					mapTotal.put("nmFilial",nmFilial);
					mapTotal.put("dsRota",dsRota);
					mapTotal.put("tpPostoPassagem","");
					mapTotal.put("nmMunicipio","");
					mapTotal.put("sgUnidadeFederativa","");
					mapTotal.put("nmPais","");
					mapTotal.put("tpSentidoCobranca","");
					mapTotal.put("tpFormaCobranca","Total");
					mapTotal.put("idRotaColetaEntrega",idRotaColetaEntregaTotal);
					mapTotal.put("idFilial",idFilialTotal);
					mapTotal.put("dsRodovia","");
					mapTotal.put("sgRodovia","");
					mapTotal.put("nrKm",null);
					mapTotal.put("nomeConcessionaria","");
					mapTotal.put("totalizador","T");
					
					mapTotal.put("Total",listaTotalizadora);
					registros.add(mapTotal);
				}	
			}
			
			
			//fim ---- se for o ultimo registro
			
			
		}
		
		
		//*********************************************fim da iteração dos registros
		
		for (Iterator iter=registros.iterator();iter.hasNext();){
			Map mapRegistro = (Map)iter.next();
			if(mapRegistro.get("totalizador")== null){
			String nmMunicipioRota = mapRegistro.get("nmMunicipio").toString()+mapRegistro.get("idRotaColetaEntrega").toString()+mapRegistro.get("idPostoPassagem").toString();
			Object valoresMunicipio = ((Object[])tabelas.get(nmMunicipioRota));
			if(valoresMunicipio != null)
				mapRegistro.put(mapRegistro.get("nmMunicipio"),valoresMunicipio);
			}
		}
			
			
		/* Monta o SQL com os nomes das colunas */
		for(int j=1;j<=setCrosstab.size();j++)
		{
			names += ", COLUMN" +j; 
		}
		
		return new ColumnsDefinition(setCrosstab.size(),setCrosstab,names,registros);
	}
	
	/**
	 *  Metodo que grava os dados na base.
	 *  
	 * @param JdbcTemplate instancia de JdbcTemplate, List com os dados a serem inseridos.
	 * @return void  
	 */
	private void populateTable(JdbcTemplate jdbcTemplate, List listDados, Long idMoedaPais) {	
		
		columnsDefinition = getColumns(listDados, idMoedaPais);
		int cont = 0;
		
		/* Monta os inserts e insere na base. */
		for (Iterator it = columnsDefinition.getRegistros().iterator(); it.hasNext(); ) {
			Map mapRegistros = (Map)it.next();
			ArrayList valoresDinamicos = new ArrayList();
			Object[] valoresDinamicosOb = ((Object[])mapRegistros.get(mapRegistros.get("nmMunicipio")));
			if(valoresDinamicosOb==null)
				valoresDinamicosOb = ((Object[])mapRegistros.get(mapRegistros.get("tpFormaCobranca")));
			
			for(int k=0; k<valoresDinamicosOb.length;k++){
				valoresDinamicos.add(valoresDinamicosOb[k]);
			}
			
			String sgFilial = mapRegistros.get("sgFilial").toString();
			String nmFilial = mapRegistros.get("nmFilial").toString();
			String dsRota = mapRegistros.get("dsRota").toString();
			String tpPostoPassagem = mapRegistros.get("tpPostoPassagem").toString();
			String nmMunicipio = mapRegistros.get("nmMunicipio").toString();
			String sgUnidadeFederativa = mapRegistros.get("sgUnidadeFederativa").toString();
			String nmPais = mapRegistros.get("nmPais").toString();
			String tpSentidoCobranca = mapRegistros.get("tpSentidoCobranca").toString();
			String tpFormaCobranca = mapRegistros.get("tpFormaCobranca").toString();
			Long idRotaColetaEntrega = Long.valueOf(mapRegistros.get("idRotaColetaEntrega").toString());
			Long idFilial = Long.valueOf(mapRegistros.get("idFilial").toString());
			String dsRodovia = "";
			if(mapRegistros.get("dsRodovia")!= null)
				dsRodovia = mapRegistros.get("dsRodovia").toString();
			String sgRodovia = mapRegistros.get("sgRodovia").toString();
			Integer nrKm = null;
			if(mapRegistros.get("nrKm")!=null)
				nrKm= Integer.valueOf(mapRegistros.get("nrKm").toString());
			String nomeConcessionaria = mapRegistros.get("nomeConcessionaria").toString();
			String totalizador = "";
			if(mapRegistros.get("totalizador")!=null){
				if(cont == 0)
					totalizador= "P";
				else
					totalizador= mapRegistros.get("totalizador").toString();
				cont++;
			}
			StringBuffer sb = new StringBuffer("INSERT INTO " + NOME_TABELA +
					"(" +
					"SG_FILIAL, " +
					"NM_FILIAL," +
					"DS_ROTA, " +
					"TP_POSTO_PASSAGEM, " +
					"NM_MUNICIPIO, " +
					"SG_UNIDADE_FEDERATIVA, " +
					"NM_PAIS, " +
					"TP_SENTIDO_COBRANCA, " +
					"TP_FORMA_COBRANCA," +
					"ID_ROTA_COLETA_ENTREGA, " +
					"ID_FILIAL, " +
					"DS_RODOVIA," +
					"SG_RODOVIA ,  " +
					"NR_KM,  " +
					"NM_PESSOA, " +
					"DS_SIMBOLO, " +
					"BL_TOTAL " +
					columnsDefinition.getSqlNameColumns() + ") " +
					"VALUES("
							+"'"+sgFilial+"',"
							+"'"+nmFilial+"',"
							+"'"+dsRota+"',"
							+"'"+tpPostoPassagem+"',"
							+"'"+nmMunicipio+"',"
							+"'"+sgUnidadeFederativa+"',"
							+"'"+ nmPais +"',"
							+"'"+tpSentidoCobranca+"',"
							+"'"+tpFormaCobranca+"',"
							+idRotaColetaEntrega+","
							+idFilial+","
							+"'"+dsRodovia+"',"
							+"'"+sgRodovia+"',"
							+nrKm+","
							+"'"+nomeConcessionaria+"',"
							+null+","
							+"'"+totalizador+"'");
			
			for (Iterator it2 = valoresDinamicos.iterator(); it2.hasNext(); ) {
				sb.append(", "+it2.next());
			}		
			
			sb.append(")\n");
			jdbcTemplate.execute(sb.toString());
		}
		
	}
	
	/* Metodo que monta os parameters do relatorio. */
	private void montaParametersReport(Map parameters,ColumnsDefinition cd)
	{		 
		parameters.put("usuarioEmissor",SessionContext.getUser().getNmUsuario());		
		
		Set c = cd.getColumns();
		Iterator it = c.iterator();
		int i=1;
		while(it.hasNext())
		{			
			parameters.put("PCOLUMN" + i,it.next().toString());
			i++;
		}	
	}
	
	public JRReportDataObject execute(Map parameters) throws Exception {	
		
		TypedFlatMap tfm = (TypedFlatMap) parameters;
		
        SqlTemplate sql = getSqlTemplate(tfm);
        
        /*Query geral que retorna os dados para serem inseridos na temporária*/
         List result = getJdbcTemplate().queryForList(sql.getSql(), JodaTimeUtils.jdbcPureParamConverter(getJdbcTemplate(), sql.getCriteria()));
        
        /* Insere os dados na tebela temporaria do banco */
        Long idMoedaPais = null;
        if(tfm.getLong("moedaPais.idMoedaPais")!= null){
        	idMoedaPais = tfm.getLong("moedaPais.idMoedaPais");
        }
        populateTable(getJdbcTemplate(),result,idMoedaPais);
        
        /* passar para o relatorio qual o numero totsl de colunas(CrossTab) que ele terá. */
		parameters.put(ReportServiceSupport.CT_NUMBER_OF_COLS, new Integer[]{Integer.valueOf((columnsDefinition.getTotColumns()))});
		
		/* Monta os parrameters desse relatorio , para serem mandados ao jasper. */
		montaParametersReport(parameters,columnsDefinition);
		
		parameters.put("parametrosPesquisa", sql.getFilterSummary());
		parameters.put(JRReportDataObject.EXPORT_MODE_PARAM,parameters.get("tpFormatoRelatorio"));
	    
        /*Query que lê da temporária e envia para o jasper*/
		JRReportDataObject jr = executeQuery("select * from " + NOME_TABELA,parameters);	
		
		jr.setParameters(parameters);		
		
		return jr;
	}
	
	private SqlTemplate getSqlTemplate(TypedFlatMap  criteria) {
		SqlTemplate sql = createSqlTemplate();
		//PROJEÇÃO
		sql.addProjection("DISTINCT FIL.ID_FILIAL");
		sql.addProjection("FIL.SG_FILIAL");
		sql.addProjection("PESFIL.NM_FANTASIA","NM_FILIAL");
		
		sql.addProjection("RCE.ID_ROTA_COLETA_ENTREGA");
		sql.addProjection("RCE.DS_ROTA");
		sql.addProjection("RCE.NR_ROTA");
		
		sql.addProjection("PP.ID_POSTO_PASSAGEM");
		sql.addProjection("PP.TP_POSTO_PASSAGEM");
		
		sql.addProjection("MPP.NM_MUNICIPIO");
		
		sql.addProjection("RO.SG_RODOVIA");
		sql.addProjection("RO.DS_RODOVIA");
		sql.addProjection("PP.NR_KM");
		sql.addProjection("PP.TP_SENTIDO_COBRANCA");
		sql.addProjection("TPP.TP_FORMA_COBRANCA");
		
		sql.addProjection("TMT.ID_TIPO_MEIO_TRANSPORTE");
		sql.addProjection("SUBSTR(TMT.DS_TIPO_MEIO_TRANSPORTE,0,3)||DECODE (TMT_COMP.DS_TIPO_MEIO_TRANSPORTE, null, '(' || Etmt.QT_EIXOS || ')',  '+'|| SUBSTR(TMT_COMP.DS_TIPO_MEIO_TRANSPORTE,0,3) || '(' || (NVL(Etmt.QT_EIXOS,0) + NVL(ETmtcomp.QT_EIXOS,0)) || ')')","DS_TIPO_MEIO_TRANSPORTE");
		
		sql.addProjection("NVL(Etmt.QT_EIXOS,0) + NVL(ETmtcomp.QT_EIXOS,0)","QT_EIXOS");
		
		sql.addProjection("TMT.DS_TIPO_MEIO_TRANSPORTE","DS_TIPO_MEIO_TRANSPORTE_N");
		
		sql.addProjection("TMT_COMP.DS_TIPO_MEIO_TRANSPORTE","DS_TIPO_MEIO_TRANSPORTE_COMP");
		
		
		//FROM
		sql.addFrom("POSTO_PASSAGEM_ROTA_COL_ENT","PPRCE");
		sql.addFrom("ROTA_COLETA_ENTREGA","RCE");
		sql.addFrom("FILIAL","FIL");
		sql.addFrom("PESSOA","PESFIL");
		sql.addFrom("POSTO_PASSAGEM","PP");
		sql.addFrom("MUNICIPIO","MPP");
		
		sql.addFrom("RODOVIA","RO");
				
		sql.addFrom("TARIFA_POSTO_PASSAGEM","TPP");
		sql.addFrom("TIPO_MEIO_TRANSPORTE","TMT");
		sql.addFrom("TIPO_MEIO_TRANSPORTE","TMT_COMP");
		sql.addFrom("EIXOS_TIPO_MEIO_TRANSPORTE","ETmt");
        sql.addFrom("EIXOS_TIPO_MEIO_TRANSPORTE","ETmtcomp");
		
			
		//JOIN
		sql.addJoin("PPRCE.ID_ROTA_COLETA_ENTREGA","RCE.ID_ROTA_COLETA_ENTREGA");
		sql.addJoin("RCE.ID_FILIAL","FIL.ID_FILIAL");
		sql.addJoin("FIL.ID_FILIAL","PESFIL.ID_PESSOA");
		
		sql.addJoin("PPRCE.ID_POSTO_PASSAGEM","PP.ID_POSTO_PASSAGEM");
		sql.addJoin("PP.ID_MUNICIPIO","MPP.ID_MUNICIPIO");
		
		
		sql.addJoin("PP.ID_RODOVIA","RO.ID_RODOVIA(+)");
		
		sql.addJoin("TPP.ID_POSTO_PASSAGEM","PP.ID_POSTO_PASSAGEM");
		
		sql.addJoin("TMT.ID_TIPO_MEIO_TRANSPORTE_COMPOS","TMT_COMP.ID_TIPO_MEIO_TRANSPORTE(+)");
		
		sql.addJoin("TMT.ID_TIPO_MEIO_TRANSPORTE" , "ETmt.ID_TIPO_MEIO_TRANSPORTE");

		sql.addJoin("TMT.ID_TIPO_MEIO_TRANSPORTE_COMPOS" , "ETmtcomp.ID_TIPO_MEIO_TRANSPORTE(+)");
		
		
		//CRITERIAS
		sql.addCriteria("TMT.TP_MEIO_TRANSPORTE","=","R");
		sql.addCriteria("TMT.TP_SITUACAO","=","A");
		
		sql.addCustomCriteria("NOT EXISTS(SELECT 1 FROM  TIPO_MEIO_TRANSPORTE TMTin WHERE TMTin.ID_TIPO_MEIO_TRANSPORTE_COMPOS = TMT.ID_TIPO_MEIO_TRANSPORTE AND TMTin.TP_SITUACAO = 'A')");

				
		if(criteria.getLong("filial.idFilial")!= null){
			sql.addCriteria("FIL.ID_FILIAL","=",criteria.getLong("filial.idFilial"));
			sql.addFilterSummary("filial", criteria.getString("filial.sgFilial")+" - "+criteria.getString("filial.pessoa.nmFantasia"));
		}
		if(criteria.getLong("rotaColetaEntrega.idRotaColetaEntrega")!=null){
			sql.addCriteria("RCE.ID_ROTA_COLETA_ENTREGA","=",criteria.getLong("rotaColetaEntrega.idRotaColetaEntrega"));
			sql.addFilterSummary("rota",criteria.getString("rotaColetaEntrega.nrRota")+" - "+criteria.getString("rotaColetaEntrega.dsRota"));
		}
		if(criteria.getLong("municipio.idMunicipio")!= null){
			sql.addCriteria("MPP.ID_MUNICIPIO","=",criteria.getLong("municipio.idMunicipio"));
			sql.addFilterSummary("localizacao", criteria.getString("municipio.nmMunicipio")+" - "+criteria.getString("uf")+" - "+criteria.getString("pais"));
		}
		if(criteria.getString("descricaoMoeda")!= null)
			sql.addFilterSummary("converterParaMoeda",criteria.getString("descricaoMoeda"));
		
		sql.addCriteria("PPRCE.DT_VIGENCIA_INICIAL","<=",JTDateTimeUtils.getDataAtual());
		sql.addCriteria("PPRCE.DT_VIGENCIA_FINAL",">=",JTDateTimeUtils.getDataAtual());
		
		sql.addCriteria("TPP.DT_VIGENCIA_INICIAL","<=",JTDateTimeUtils.getDataAtual());
		sql.addCriteria("TPP.DT_VIGENCIA_FINAL",">=",JTDateTimeUtils.getDataAtual());
		
		sql.addOrderBy("FIL.SG_FILIAL");
		sql.addOrderBy("RCE.NR_ROTA");
		sql.addOrderBy("PP.TP_POSTO_PASSAGEM");
		sql.addOrderBy("MPP.NM_MUNICIPIO");
		sql.addOrderBy("QT_EIXOS");
		sql.addOrderBy("TMT.DS_TIPO_MEIO_TRANSPORTE");
		sql.addOrderBy("TMT_COMP.DS_TIPO_MEIO_TRANSPORTE");
		
		return sql;
	}
	
	//imprime o rodapé dos tipos de meio de transporte
	public JRDataSource executeTipoMeioTransporteAtivo() throws Exception {
		SqlTemplate sql = createSqlTemplate();
		sql.addProjection("SUBSTR(TMT.DS_TIPO_MEIO_TRANSPORTE,0,3)||' = '||TMT.DS_TIPO_MEIO_TRANSPORTE","DS_TIPO_MEIO_TRANSPORTE");
		
		sql.addFrom("TIPO_MEIO_TRANSPORTE","TMT");
		sql.addCriteria("TMT.TP_SITUACAO","=","A");
		sql.addCriteria("TMT.TP_MEIO_TRANSPORTE","=","R");
				
		sql.addOrderBy("TMT.DS_TIPO_MEIO_TRANSPORTE");
		
		
		List result = getJdbcTemplate().queryForList(sql.getSql(),sql.getCriteria());
		
		if (result==null) return null;

        Map mapDados = new HashMap();          

        List newList = new ArrayList(4);

        int i=0;

        ListIterator lit = result.listIterator();

        while(lit.hasNext())

        {

              Map aux  = (Map)lit.next();            

              mapDados.put("DS_TIPO_MEIO_TRANSPORTE" + i++,aux.get("DS_TIPO_MEIO_TRANSPORTE"));

              if (i==4)

              {                                                  

                    newList.add(mapDados);

                    mapDados = new HashMap();

                    i=0;

              }

        }

        if (i!=0) newList.add(mapDados); /* No caso do ultimo registro nao chegar a 3 */
        
        return new JRMapCollectionDataSource(newList);
	}
	
	@Override
	public void postExecute(JdbcTemplate jdbcTemplate, Map parameters  ){
		jdbcTemplate.execute("delete from " + NOME_TABELA);
	}

	public void setDomainValueService(DomainValueService domainValueService) {
		this.domainValueService = domainValueService;
	}

	public void setPostoPassagemService(PostoPassagemService postoPassagemService) {
		this.postoPassagemService = postoPassagemService;
	}

	public void setTipoPagamentoPostoDAO(TipoPagamentoPostoDAO tipoPagamentoPostoDAO) {
		this.tipoPagamentoPostoDAO = tipoPagamentoPostoDAO;
	}

	

}
