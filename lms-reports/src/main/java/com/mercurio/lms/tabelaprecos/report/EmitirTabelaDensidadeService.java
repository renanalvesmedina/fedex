package com.mercurio.lms.tabelaprecos.report;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.springframework.jdbc.core.JdbcTemplate;

import com.mercurio.adsm.framework.report.JRReportDataObject;
import com.mercurio.adsm.framework.report.ReportServiceSupport;
import com.mercurio.lms.configuracoes.ConfiguracoesFacade;
import com.mercurio.lms.configuracoes.util.MapUtilsPlus;
import com.mercurio.lms.util.FormatUtils;
import com.mercurio.lms.util.session.SessionUtils;
import com.mercurio.lms.vendas.model.service.TabelasClienteService;
import com.mercurio.lms.vendas.util.TabelasClienteUtil;


/**
 * Generated by: ADSM ActionGenerator
 *  
 * Não inserir documentação após ou remover a tag do XDoclet a seguir.
 * O valor do <code>id</code> informado abaixo deve ser utilizado para referenciar este serviço.
 * @spring.bean id="lms.tabelaprecos.report.emitirTabelaDensidadeService" 
 * 
 *  ************************************************************************************************************************************************ <BR>
 *  *** Relatório funcional padrão de exemplos ***************************************************************************************************** <BR>
 *  *** Documentado e feito por: Diego Pacheco ***************************************************************************************************** <BR> 
 *  ************************************************************************************************************************************************ <BR>
 * 																																							<BR>
 * Uso de ThreadLocal: Como os "Services" estão em um pool gerenciado pelo String, acontece um fenomeno com as variaveis de instancia(variaveis de classe)  <BR>
 * 					   que faz com que os valores fiquei sujos isso pode provocar "dirty read"(Leitura suja) por isso devemos guardas e acessar esses dados <BR>
 * 					   atravez de ThreadLocal. Na class consta os metodos: setLocalVariableValue e getLocalVariableValue para tal serviço.				    <BR>
 * 
 * 
 * ET: 30.03.02.02 - Tabela de Densidade 
 *  
 * @author Diego Pacheco
 * 
 */	 
public class EmitirTabelaDensidadeService extends ReportServiceSupport {
	     
	private TabelasClienteService tabelasClienteService;
	
	/* Nome da Tebela temporaria */
	private static final String NOME_TABELA = "TMP_DENSIDADE"; 	
	    
	/* Variaveis que contem os SQLs necessarios a execução do relatorio. */
	private static final String SQL;
	private static final String SQL_COUNT;
	private static final String SQL_MOEDA;
	
	/**
	 * Para guardar o idTabelaPreco e o dsSimbolo e compartilhar entre metodos
	 */
	private static final ThreadLocal dadosClasseThread = new ThreadLocal();
	
    /**
     * Seta o atributo local identificado pela chave com o valor
     * 
     * @param key chave do atributo local
     * @param value valor do atributo local
     */
    private void setLocalVariableValue(Object key, Object value)
    {
    	Map map = (Map)dadosClasseThread.get();
    	if(map == null) map = new HashMap();
    	
    	map.put(key, value);
    	dadosClasseThread.set(map);
    }
    
    /**
     * Retorna valor do atributo local identificado pela chave
     * 
     * @param key chave do atributo local
     * @return valor do atributo local
     */
    private Object getLocalVariableValue(Object key)
    {
    	Map map = (Map)dadosClasseThread.get();
    	if(map == null) return null;
    	
    	return map.get(key);
    }

    
	/** Inner Class utilizada para a definição de uma coluna. 
	 *  Está é uma classe Helper que ajuda na programação do artefato.
	 *  ONDE:
	 *  	  totColumns -> É o total de colunas que a cross-tab tem.
	 * 			 columns -> Set, com as colunas da cross-tab.
	 * 	  sqlNameColumns -> Armazena o sql de inserção das colunas da cross-tab.
	 * 			  tabela -> HashMap com todos os dados vindos da query principal e outrora o cerne de dados.
	 * 
	 **/
	private class ColumnsDefinition
	{
		
		private int totColumns;
		private Set columns = new LinkedHashSet();
		private String sqlNameColumns;
		private HashMap tabela;
		
		public ColumnsDefinition(){}
		
		public ColumnsDefinition(int totColumns, Set columns, String sqlNameColumns,HashMap tabela) {
			this.totColumns = totColumns;
			this.columns = columns;
			this.sqlNameColumns = sqlNameColumns;
			this.tabela = tabela;
		}
		
		public Set getColumns() {
			return columns;
		}

		public void setColumns(Set columns) {
			this.columns = columns;
		}

		public String getSqlNameColumns() {
			return sqlNameColumns;
		}

		public void setSqlNameColumns(String sqlNameColumns) {
			this.sqlNameColumns = sqlNameColumns;
		}

		public int getTotColumns() {
			return totColumns;
		}

		public void setTotColumns(int totColumns) {
			this.totColumns = totColumns;
		}

		public HashMap getTabela() {
			return tabela;
		}

		public void setTabela(HashMap tabela) {
			this.tabela = tabela;
		}		
		
	}
	
	/* Serviços utilizados pelo relatório. */
	private EmitirTabelasMinimoProgressivoService emitirTabelasMinimoProgressivoService;
	private ConfiguracoesFacade configuracoesFacade;
	
	
	/**
	 *  Query principal que traz os dados do relatório.
	 *   
	 * */
	static {
		StringBuffer sql = new StringBuffer();
		sql.append("select ")
		.append("TARIFA.CD_TARIFA_PRECO as TARIFA, ")
		.append("DENSIDADE.TP_DENSIDADE as DENSIDADE, ")
		.append("(DENSIDADE.VL_FATOR * TARIFA.VL_PRECO_FRETE) as VALOR_COLUNA, ")
		.append("ADVALOREM.VL_PRECO_FRETE AS ADVALOREM ")
		
		.append("from ") 
		.append("( ")
		.append("select ")
		.append("TP_DENSIDADE, ")
		.append("VL_FATOR     ")
		.append("from  ")
		.append("DENSIDADE where TP_SITUACAO = 'A' ")
		.append(") DENSIDADE, ")

		.append("( ")
		.append("select ")
		.append("TP.ID_TARIFA_PRECO as ID_TARIFA_PRECO, ")
		.append("TP.CD_TARIFA_PRECO as CD_TARIFA_PRECO,  ")
		.append("F.VL_PRECO_FRETE, ")
		.append("T.ID_PARCELA_PRECO ") 
		.append("from ")
		.append("TABELA_PRECO_PARCELA T, ")
		.append("PRECO_FRETE F, ")
		.append("TARIFA_PRECO TP, ")
		.append("PARCELA_PRECO PP ")
		.append("where ")
		.append("T.ID_PARCELA_PRECO = PP.ID_PARCELA_PRECO ")
		.append("and  T.ID_TABELA_PRECO_PARCELA = F.ID_TABELA_PRECO_PARCELA ")
		.append("and  F.ID_TARIFA_PRECO = TP.ID_TARIFA_PRECO ")
		.append("and  PP.CD_PARCELA_PRECO = 'IDFreteQuilo' ")
		.append("and  T.ID_TABELA_PRECO = ? ")
		.append(") TARIFA, ")
		 
		.append("( ") 
		.append("select ")
		.append("TP.ID_TARIFA_PRECO, ")
		.append("TP.CD_TARIFA_PRECO, ")
		.append("F.VL_PRECO_FRETE, ")
		.append("T.ID_PARCELA_PRECO ")
		.append("from ")
		.append("TABELA_PRECO_PARCELA T, ")
		.append("PRECO_FRETE F, ")
		.append("TARIFA_PRECO TP, ")
		.append("PARCELA_PRECO PP ")
		.append("where ")
		.append("T.ID_PARCELA_PRECO = PP.ID_PARCELA_PRECO ")		
		.append("and  T.ID_TABELA_PRECO_PARCELA = F.ID_TABELA_PRECO_PARCELA ")
		.append("and  F.ID_TARIFA_PRECO = TP.ID_TARIFA_PRECO ")
		.append("and  PP.CD_PARCELA_PRECO = 'IDAdvalorem' ")
		.append("and  T.ID_TABELA_PRECO = ? ")
		.append(") ADVALOREM ")

		.append("where ")
		.append(" ADVALOREM.ID_TARIFA_PRECO = TARIFA.ID_TARIFA_PRECO ")	
		.append("ORDER BY TARIFA, DENSIDADE ASC");

		SQL = sql.toString();
		
		SQL_COUNT = "select " +
		 			"count(TP_DENSIDADE) as tot " +								 
		 			"from  " +
		 			"DENSIDADE where TP_SITUACAO = 'A' "; 
		
		SQL_MOEDA = " select " + 
	      			" DS_SIMBOLO " +
	      			" from " + 
	      			" TABELA_PRECO t, MOEDA m " +
	      			" where " +
	      			" t.ID_MOEDA = m.ID_MOEDA and " +
	      			" t.id_tabela_preco = ? ";		
	}	
	
	
	/**
	 * Metodo principal que é executado pelo framework adsm.
	 * O Processamento inicia aqui. 
	 */
	public JRReportDataObject execute(Map parameters) throws Exception {	
		return null;
	}
		
	public List<Map<String, String>> findDados(Map parameters) throws Exception {
		
		parameters.put("usuarioEmissor",SessionUtils.getUsuarioLogado().getNmUsuario());
		
		
		StringBuffer sql = new StringBuffer();
		sql.append("select ")
		.append("TARIFA.CD_TARIFA_PRECO as TARIFA, ")
		.append("DENSIDADE.TP_DENSIDADE as DENSIDADE, ")
		.append("(DENSIDADE.VL_FATOR * TARIFA.VL_PRECO_FRETE) as VALOR_COLUNA, ")
		.append("ADVALOREM.VL_PRECO_FRETE AS ADVALOREM ")
		
		.append("from ") 
		.append("( ")
		.append("select ")
		.append("TP_DENSIDADE, ")
		.append("VL_FATOR     ")
		.append("from  ")
		.append("DENSIDADE where TP_SITUACAO = 'A' ")
		.append(") DENSIDADE, ")
		
		.append("( ")
		.append("select ")
		.append("TP.ID_TARIFA_PRECO as ID_TARIFA_PRECO, ")
		.append("TP.CD_TARIFA_PRECO as CD_TARIFA_PRECO,  ")
		.append("F.VL_PRECO_FRETE, ")
		.append("T.ID_PARCELA_PRECO ") 
		.append("from ")
		.append("TABELA_PRECO_PARCELA T, ")
		.append("PRECO_FRETE F, ")
		.append("TARIFA_PRECO TP, ")
		.append("PARCELA_PRECO PP ")
		.append("where ")
		.append("T.ID_PARCELA_PRECO = PP.ID_PARCELA_PRECO ")
		.append("and  T.ID_TABELA_PRECO_PARCELA = F.ID_TABELA_PRECO_PARCELA ")
		.append("and  F.ID_TARIFA_PRECO = TP.ID_TARIFA_PRECO ")
		.append("and  PP.CD_PARCELA_PRECO = 'IDFreteQuilo' ")
		.append("and  T.ID_TABELA_PRECO = ? ")
		.append(") TARIFA, ")
		 
		.append("( ") 
		.append("select ")
		.append("TP.ID_TARIFA_PRECO, ")
		.append("TP.CD_TARIFA_PRECO, ")
		.append("F.VL_PRECO_FRETE, ")
		.append("T.ID_PARCELA_PRECO ")
		.append("from ")
		.append("TABELA_PRECO_PARCELA T, ")
		.append("PRECO_FRETE F, ")
		.append("TARIFA_PRECO TP, ")
		.append("PARCELA_PRECO PP ")
		.append("where ")
		.append("T.ID_PARCELA_PRECO = PP.ID_PARCELA_PRECO ")		
		.append("and  T.ID_TABELA_PRECO_PARCELA = F.ID_TABELA_PRECO_PARCELA ")
		.append("and  F.ID_TARIFA_PRECO = TP.ID_TARIFA_PRECO ")
		.append("and  PP.CD_PARCELA_PRECO = 'IDAdvalorem' ")
		.append("and  T.ID_TABELA_PRECO = ? ")
		.append(") ADVALOREM ")

		.append("where ")
		.append(" ADVALOREM.ID_TARIFA_PRECO = TARIFA.ID_TARIFA_PRECO ")	
		.append("ORDER BY TARIFA, DENSIDADE ASC");
		
		/* Obtem os dados do relatório */
		Long idTabelaPreco = Long.valueOf(parameters.get("tipoTabelaPreco.idTabelaPreco").toString());
		List<Map<String, String>> result = getJdbcTemplate().queryForList(sql.toString(), new Long[]{idTabelaPreco,idTabelaPreco});
		
	for (Map map : result) {
		map.put("VALOR_COLUNA", FormatUtils.formatDecimal(TabelasClienteUtil.FORMATO_5_CASAS, MapUtilsPlus.getBigDecimal(map,"VALOR_COLUNA")));
		map.put("ADVALOREM", FormatUtils.formatDecimal(TabelasClienteUtil.FORMATO_2_CASAS, MapUtilsPlus.getBigDecimal(map,"ADVALOREM")));	
	}
	
		TabelasClienteUtil.montaSubReportsTabelaPreco(idTabelaPreco, getSubReportsToCall(), getConfiguracoesFacade(),  getJdbcTemplate(), parameters );		
	
		return result;
	}
	
	
	/**
	 *  Metodo que grava os dados na base.
	 *  
	 * @author Diego Pacheco - LMS - GT5
	 * @param JdbcTemplate instancia de JdbcTemplate, List com os dados a serem inseridos.
	 * @return void  
	 */
	private void populateTable(JdbcTemplate jdbcTemplate, List listDados) {	
		
		ColumnsDefinition columnsDefinition = getColumns(listDados);
		this.setColumnsDefinition(columnsDefinition);
		
		/* Monta os inserts e insere na base. */
		for (Iterator it = columnsDefinition.getTabela().keySet().iterator(); it.hasNext(); ) {
			String tarifa = (String)it.next();
			List lista    = (List)columnsDefinition.getTabela().get(tarifa);
			
			StringBuffer sb = new StringBuffer("INSERT INTO " + NOME_TABELA + " (TARIFA, ADVALOREM" + columnsDefinition.getSqlNameColumns() + ") VALUES('"+ tarifa +"'  ");			
			for (Iterator it2 = lista.iterator(); it2.hasNext(); ) {
				sb.append(", "+it2.next());
			}			
			
			sb.append(")\n");
			jdbcTemplate.execute(sb.toString());		
		}
		
	}	
	

	/** 
	 *  Metodo que obtem as definições das colunas 
	 *  Pega os dados oriundos da query principal e passa
	 *  os memos para a uma inmstancia de ColumnsDefinitions, 
	 *  efetuando também processamento nesses dados.
	 * 
	 **/
	private ColumnsDefinition getColumns(List listDados)
	{
		Set setCrosstab = new LinkedHashSet();		
		HashMap tabelas = new HashMap();
		String names = "";
		
		int i = 0;
		/* Descobre as Colunas(Headers) do relatorio. */
		for (Iterator it = listDados.iterator(); it.hasNext(); i++) { 
			Map map = (Map)it.next();
			
			String tarifa = (String)map.get("TARIFA");
			String column = (String)map.get("DENSIDADE");
			Object dado   = map.get("VALOR_COLUNA"); 
			Object adv   = map.get("ADVALOREM");
			
			if (!tabelas.containsKey(tarifa)) 
			{
				tabelas.put(tarifa, new ArrayList());
				((ArrayList)tabelas.get(tarifa)).add(adv);			
			}
			((ArrayList)tabelas.get(tarifa)).add(dado);				
			
			setCrosstab.add(column);			
			
		}	
		
		/* Monta o SQL com os nomes das colunas */
		for(int j=1;j<=setCrosstab.size();j++)
		{
			names += ", COLUMN" +j; 
		}
		
		return new ColumnsDefinition(setCrosstab.size(),setCrosstab,names,tabelas);
	}
	

	/* Metodo que monta os parameters do relatorio. */
	private void montaParametersReport(Map parameters,ColumnsDefinition cd)
	{		 
		parameters.put("usuarioEmissor",SessionUtils.getUsuarioLogado().getNmUsuario());		
		
		Set c = cd.getColumns();
		Iterator it = c.iterator();
		int i=1;
		while(it.hasNext())
		{			
			parameters.put("PCOLUMN" + i,it.next().toString());
			i++;
		}	
		
		/* Monta os subreports de formalidades e generalidades */
		createtListMapDataSource(parameters,getJdbcTemplate());	
		
	}
	
	
	/**
	 * Monta os DatSources necessários ao subr4elatórios.
	 * @param parameters Map com os parameters.
	 * @param jdbc JdbcTemplate injetado pelo Spring.
	 */
	private void createtListMapDataSource(Map parameters,JdbcTemplate jdbc)
	{
		Long idTabelaPreco =  MapUtilsPlus.getLong(parameters,"tipoTabelaPreco.idTabelaPreco",null);

		getTabelasClienteService().montaSubReportsTabelaPreco(
													   idTabelaPreco,
													   getSubReportsToCall(),
													   getConfiguracoesFacade(),
													   getJdbcTemplate(),
													   parameters
													   );		
		int totRegistros = getJdbcTemplate().queryForInt("Select COUNT(*) from " + NOME_TABELA);
		parameters.put("TOTAL", Integer.valueOf(totRegistros));
		
		getTabelasClienteService().setEspacoQuebra(31,3,totRegistros,0,8,parameters);               
	}
	
	
	/**
	 *  Metodo que define quais serão os sub-relatórios a serem usados.
	 * 
	 **/
	private int[] getSubReportsToCall()
	{
		return new int[]{
				TabelasClienteUtil.SUBREPORT_GENERALIDADES_TABELA_PRECO,
				TabelasClienteUtil.SUBREPORT_FORMALIDADES,
				TabelasClienteUtil.SUBREPORT_SERVICOSAD
			};		
	}
	
	/**
	 * Descobre o simbolo da Moeda padrão.
	 * @param idTabelaPreco
	 * @return String o simbolo da moeda.
	 */
	public String getDsSimboloMoeda(Long idTabelaPreco)
	{
		List result = getJdbcTemplate().queryForList(SQL_MOEDA,new Long[]{idTabelaPreco});
		if (result==null || result.size()==0 )
		{
			return "";
		}
		else
		{
			Map mapResult = (Map)result.get(0);
			return (String)mapResult.get("DS_SIMBOLO");
		}
	}

	
	// getters and setters.
	
	public EmitirTabelasMinimoProgressivoService getEmitirTabelasMinimoProgressivoService() {
		return emitirTabelasMinimoProgressivoService;
	}

	public void setEmitirTabelasMinimoProgressivoService(
			EmitirTabelasMinimoProgressivoService emitirTabelasMinimoProgressivoService) {
		this.emitirTabelasMinimoProgressivoService = emitirTabelasMinimoProgressivoService;
	}

	public ConfiguracoesFacade getConfiguracoesFacade() {
		return configuracoesFacade;
	}

	public void setConfiguracoesFacade(ConfiguracoesFacade configuracoesFacade) {
		this.configuracoesFacade = configuracoesFacade;
	}

	public ColumnsDefinition getColumnsDefinition() {
		return (ColumnsDefinition)this.getLocalVariableValue("columnsDefinition");
	}

	public void setColumnsDefinition(ColumnsDefinition columnsDefinition) {
		this.setLocalVariableValue("columnsDefinition", columnsDefinition);
	}	

	/**
	 * @return the tabelasClienteService
	 */
	public TabelasClienteService getTabelasClienteService() {
		return tabelasClienteService;
}

	/**
	 * @param tabelasClienteService the tabelasClienteService to set
	 */
	public void setTabelasClienteService(TabelasClienteService tabelasClienteService) {
		this.tabelasClienteService = tabelasClienteService;
	}	
}


