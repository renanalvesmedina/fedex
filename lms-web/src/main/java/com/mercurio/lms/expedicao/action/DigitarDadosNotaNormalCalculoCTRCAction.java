package com.mercurio.lms.expedicao.action;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import com.mercurio.adsm.framework.BusinessException;
import com.mercurio.lms.expedicao.model.CalculoFrete;
import com.mercurio.lms.expedicao.model.Conhecimento;
import com.mercurio.lms.expedicao.model.ParcelaDoctoServico;
import com.mercurio.lms.expedicao.model.ParcelaServico;
import com.mercurio.lms.expedicao.model.service.ConhecimentoNormalService;
import com.mercurio.lms.expedicao.util.CalculoFreteUtils;
import com.mercurio.lms.expedicao.util.ConhecimentoUtils;
import com.mercurio.lms.expedicao.util.ConstantesExpedicao;
import com.mercurio.lms.expedicao.util.ExpedicaoUtils;
import com.mercurio.lms.tabelaprecos.model.ParcelaPreco;
import com.mercurio.lms.util.session.SessionUtils;
import com.mercurio.lms.vendas.model.DivisaoCliente;

/**
 * Generated by: ADSM ActionGenerator
 * 
 * Não inserir documentação após ou remover a tag do XDoclet a seguir.
 * O valor do <code>id</code> informado abaixo deve ser utilizado para referenciar este serviço.
 * @spring.bean id="lms.expedicao.digitarDadosNotaNormalCalculoCTRCAction"
 */

public class DigitarDadosNotaNormalCalculoCTRCAction extends AbstractCalculoFreteAction {
	private ConhecimentoNormalService conhecimentoNormalService;

	public void setConhecimentoNormalService(ConhecimentoNormalService conhecimentoNormalService) {
		this.conhecimentoNormalService = conhecimentoNormalService;
	}

	/**
	 * Método que chama o serviço para o calculo do frete manual
	 * autor Julio Cesar Fernandes Corrêa
	 * 19/12/2005
	 * @param parameters
	 * @return 
	 */
	public Map executaCalculoManual(Map parameters) {
		Conhecimento conhecimento = ConhecimentoUtils.getConhecimentoPersistentInSession();
		CalculoFrete calculoFrete = ExpedicaoUtils.getCalculoFreteInSession();
		conhecimentoNormalService.validateCalculoFreteManual(calculoFrete, conhecimento, parameters);
		return montarParcelasCalculo(conhecimento, calculoFrete);
	}

	/**
	 * Esta rotina tem por objetivo chamar as rotinas de cálculo do preço frete 
	 * e dos serviços adicionais, efetuando o cálculo do valor do CTRC.
	 * 
	 * @param idDivisaoCliente
	 * @return Parcelas Calculadas
	 */
	public Map executeCalculoFretePrimeiraFase(Long idDivisaoCliente) {
		Conhecimento conhecimento = ConhecimentoUtils.getConhecimentoPersistentInSession();
		if(idDivisaoCliente != null) {
			DivisaoCliente dc = new DivisaoCliente();
			dc.setIdDivisaoCliente(idDivisaoCliente);
			conhecimento.setDivisaoCliente(dc);
		}

		CalculoFrete calculoFrete = ExpedicaoUtils.getCalculoFreteInSession();
		calculoFrete.setIdDivisaoCliente(idDivisaoCliente);
		try {
			conhecimentoNormalService.executeCalculoFretePrimeiraFase(conhecimento, calculoFrete);			
		} catch (BusinessException businessException) {
			throw businessException;
		} finally {
			ConhecimentoUtils.setConhecimentoPersistentInSession(conhecimento);
			ExpedicaoUtils.setCalculoFreteInSession(calculoFrete);
		}
		return executeCalculoFreteSegundaFase();
	}

	/**
	 * Validações pós Calculo do Frete
	 * @return Parcelas Calculadas
	 */
	public Map executeCalculoFreteSegundaFase() {
		Conhecimento conhecimento = ConhecimentoUtils.getConhecimentoPersistentInSession();
		CalculoFrete calculoFrete = ExpedicaoUtils.getCalculoFreteInSession();
		conhecimentoNormalService.executeCalculoFreteSegundaFase(conhecimento, calculoFrete);
		return montarParcelasCalculo(conhecimento, calculoFrete);
	}

	/**
	 * Após o calculo do frete, é necessário montar as parcelas do doctoservico, além de calcular os
	 * subtotais do valor do frete e do valor dos serviços.
	 * 
	 * autor Julio Cesar Fernandes Corrêa
	 * 19/12/2005
	 * @param ds
	 * @param calculo
	 * @return
	 */
	private Map montarParcelasCalculo(Conhecimento conhecimento, CalculoFrete calculoFrete) {
		Map retorno = new HashMap();
		List parcelasDoctoServ = new ArrayList();

		/** Parcelas */
		if(calculoFrete.getBlCalculaParcelas().booleanValue() && calculoFrete.getParcelas() != null) {
			List parcelas = new ArrayList();
			CalculoFreteUtils.ordenaParcelas(calculoFrete.getParcelas());
			for (Iterator iter = calculoFrete.getParcelas().iterator(); iter.hasNext();) {
				ParcelaServico parcelaServico = (ParcelaServico) iter.next();
				ParcelaPreco parcelaPreco = parcelaServico.getParcelaPreco();
				Map parcela = new HashMap();
				parcela.put("vlParcela", parcelaServico.getVlParcela());
				parcela.put("nmParcelaPreco", parcelaPreco.getDsParcelaPreco());
				parcelas.add(parcela);
				parcelasDoctoServ.add(new ParcelaDoctoServico(parcelaServico.getVlBrutoParcela(), parcelaServico.getVlParcela(), parcelaPreco, conhecimento));
			}
			retorno.put("parcelasFrete", parcelas);
		}

		/** Servicos Adicionais */
		if(calculoFrete.getBlCalculaServicosAdicionais().booleanValue() && calculoFrete.getServicosAdicionais() != null) {
			List servicos = new ArrayList();
			for (Iterator iter = calculoFrete.getServicosAdicionais().iterator(); iter.hasNext();) {
				ParcelaServico parcelaServico = (ParcelaServico) iter.next();
				ParcelaPreco parcelaPreco = parcelaServico.getParcelaPreco();
				Map parcela = new HashMap();
				parcela.put("vlServico", parcelaServico.getVlParcela());
				parcela.put("dsServico", parcelaPreco.getDsParcelaPreco());
				servicos.add(parcela);
				parcelasDoctoServ.add(new ParcelaDoctoServico(parcelaServico.getVlBrutoParcela(), parcelaServico.getVlParcela(), parcelaPreco, conhecimento));
			}
			retorno.put("servicos", servicos);
		}
		retorno.put("vlTotalFrete", calculoFrete.getVlTotalParcelas());
		retorno.put("vlTotalServico", calculoFrete.getVlTotalServicosAdicionais());
		retorno.put("vlTotalCtrc", calculoFrete.getVlTotal());
		retorno.put("vlDesconto", calculoFrete.getVlDesconto());
		conhecimento.setParcelaDoctoServicos(parcelasDoctoServ);

		/** Seta Conhecimento na Sessao */
		ConhecimentoUtils.setConhecimentoPersistentInSession(conhecimento);
		return retorno;
	}

	/**
	 * Grava CTRC 1º Fase.
	 * @return
	 */
	public Serializable gravaCtrcPrimeiraFase() {
		HashMap retorno = conhecimentoNormalService.validateExistenciaPCE(ConhecimentoUtils.getConhecimentoPersistentInSession());
		if(retorno == null) {
			return gravaCtrcSegundaFase();
		}
		return retorno;
	}

	/**
	 * Grava CTRC 2º Fase.
	 * @return
	 */
	public Serializable gravaCtrcSegundaFase() {
		
		Conhecimento conhecimento = ConhecimentoUtils.getConhecimentoPersistentInSession();
		if(conhecimento.getMoeda() == null){
			conhecimento.setMoeda(SessionUtils.getMoedaSessao());
		}
		if(conhecimento.getFilialOrigem() == null){
			conhecimento.setFilialOrigem(conhecimento.getFilialByIdFilialOrigem());
		}
		return conhecimentoNormalService.storeConhecimento(conhecimento, ConstantesExpedicao.TIPO_ICMS);
	}

	
}
