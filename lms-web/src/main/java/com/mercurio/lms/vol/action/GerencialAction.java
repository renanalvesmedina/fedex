package com.mercurio.lms.vol.action;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang.StringUtils;
import org.joda.time.DateTime;
import org.joda.time.Duration;

import com.mercurio.adsm.framework.model.CrudAction;
import com.mercurio.adsm.framework.util.TypedFlatMap;
import com.mercurio.lms.coleta.model.EventoColeta;
import com.mercurio.lms.coleta.model.service.EventoColetaService;
import com.mercurio.lms.configuracoes.model.ParametroGeral;
import com.mercurio.lms.configuracoes.model.service.ParametroGeralService;
import com.mercurio.lms.municipios.model.Empresa;
import com.mercurio.lms.municipios.model.Filial;
import com.mercurio.lms.municipios.model.service.FilialService;
import com.mercurio.lms.util.JTDateTimeUtils;
import com.mercurio.lms.util.JTFormatUtils;
import com.mercurio.lms.util.session.SessionUtils;
import com.mercurio.lms.vol.model.VolEquipamentos;
import com.mercurio.lms.vol.model.VolGruposFrotas;
import com.mercurio.lms.vol.model.service.GerencialService;
import com.mercurio.lms.vol.model.service.VolAvisoPendenciaService;
import com.mercurio.lms.vol.model.service.VolEquipamentosService;
import com.mercurio.lms.vol.model.service.VolGruposFrotasService;


/**
 * Generated by: ADSM ActionGenerator
 *  
 * Não inserir documentação após ou remover a tag do XDoclet a seguir.
 * O valor do <code>id</code> informado abaixo deve ser utilizado para referenciar este serviço.
 * @spring.bean id="lms.vol.gerencialAction"
 */

public class GerencialAction extends CrudAction {

	private FilialService filialService ;
	private VolGruposFrotasService volGruposFrotasService;
    private GerencialService gerencialService;
    private VolEquipamentosService volEquipamentosService ;
    private VolAvisoPendenciaService volAvisoPendenciaService;
    private EventoColetaService eventoColetaService;
    private ParametroGeralService parametroGeralService;
    
	public final void setGerencialService(GerencialService serviceService) {
       this.gerencialService = serviceService;
    }
    
    public final GerencialService getGerencialService() {
        return this.gerencialService;
    }

    @Deprecated
    public void executeEnvioSms(TypedFlatMap criteria) {
    	VolEquipamentos volEquipamentos = getVolEquipamentosService().findById(criteria.getLong("idEquipamento"));
    	getVolAvisoPendenciaService().executeEnvioSMS(volEquipamentos);
    }
    
    public List findDetalhamentoGerencial(TypedFlatMap criteria) {
    	criteria.put("idFilial",SessionUtils.getFilialSessao().getIdFilial());
    	criteria.put("idUsuarioLogado", SessionUtils.getUsuarioLogado().getIdUsuario());
		return getGerencialService().findDetalhamentoGerencial(criteria);
	}
    
	/**
	 * Busca as frotas e suas respectivas informações para ser apresentada na tela de acompanhamento gerencial 
	 * @param criteria
	 * @return
	 */
	public List findAcompanhamentoGerencial(TypedFlatMap criteria) {
		
		String tipoFrota = criteria.getString("tipoFrota");
        String tipoEntrega = criteria.getString("tipoEntrega");
        String tipoColeta = criteria.getString("tipoColeta");
        
		List l = getGerencialService().findAcompanhamentoGerencial(criteria);
		if (l.isEmpty()) {
			return java.util.Collections.EMPTY_LIST;
		}
		
		List result = new ArrayList();
		
		final int IMAGEM_CELULAR = 1;
		final int BANDEIRA_BRANCA = 2;
		final int BANDEIRA_VERDE = 3;
		final int BANDEIRA_VERMELHA = 4;
		final int BANDEIRA_AMARELA = 5;
		final int BANDEIRA_AZUL = 6;
		
		
		String sGrupoFrota = "";

		//TODO rever a necessidade de haver um map vazio na list q retorna para o jsp - se retirado não renderiza a tela corretamente
		initMap(result);
		
		DateTime horaAtual = JTDateTimeUtils.getDataHoraAtual();
		
		//tempo máximo de espera para que uma coleta seja considerada como não recebida.
		ParametroGeral parametroGeral = parametroGeralService.findByNomeParametro("TEMPO_ESPERA_ALERTA_RESPOSTA_VOL",false);
		int tempEspVol = 0;
		if(StringUtils.isNotBlank(parametroGeral.getDsConteudo()) && Integer.valueOf(parametroGeral.getDsConteudo()) > 0){
			tempEspVol = Integer.valueOf(parametroGeral.getDsConteudo());
		}else {
			tempEspVol = 10;
		}
				
		long ligacoesPendentes = 0;
		int total = 0;
		int totalEntregas = 0;
		int totalEntregasBaixadas = 0;
		int totalColetas = 0;
		int totalColetasBaixadas = 0;
		int totalColetasAutomaticas = 0;
		int totalColetasSemInteracaoVol = 0;
		int totalFrequencia = 0;
		int totalFrotas = 0;
		
		
		TypedFlatMap map = null;
		
		for (Iterator iter = l.iterator();iter.hasNext();) {	
			Object[] row = (Object[])iter.next();
			String nrFrota = (String)row[0];
			Long idMeioTransporte = (Long)row[1];
			Long idEquipamento = (Long)row[2];
			String nrControleCarga = (String)row[3];
			String grupoFrota = (String)row[4];
			String vNaoPossuiCelular = (String)row[5];
			
			Long vQuantidadeChamadosFrota = (Long)row[6];
			DateTime vPrimeiroChamadoFrota = (DateTime)row[7];
			Long vTotalEntregas = (Long)row[8];
			Long vTotalEntregasBaixadas = (Long)row[9];
			Long vTotalColetas = (Long)row[10];
			Long vTotalColetasBaixadas = (Long)row[11];
			Long vTotalColetasAutomaticas = (Long)row[12];
			Long vTotalTratativas = (Long)row[13];
			
			DateTime dhOcorrenciaEntrega = (DateTime)row[14];
			DateTime dhEventoColeta = (DateTime)row[15];
			DateTime primeiraDhOcorrenciaEntrega = (DateTime)row[16];
			
			String dsNumero = (String)row[17];
			DateTime dhEnvio = (DateTime)row[18];
			String nrIdentificador = (String)row[19];
			
			DateTime dhAgendamentoColeta = (DateTime)row[20];
			DateTime dhAgendamentoEntrega = (DateTime)row[21];
			int qtdColetasSemInteracao = 0;
			
			
			if (dhOcorrenciaEntrega == null ) dhOcorrenciaEntrega = horaAtual;
			if (dhEventoColeta == null ) dhEventoColeta = horaAtual; 
			
		    map = new TypedFlatMap();	
			
			map.put("status", BANDEIRA_BRANCA );
			
			/* Status da entrega */   
			if (vTotalEntregas.equals(vTotalEntregasBaixadas)) {
				map.put("entregas.status", BANDEIRA_VERDE);
			} else if ( (dhAgendamentoEntrega == null) && (JTDateTimeUtils.getIntervalInHours(dhOcorrenciaEntrega,horaAtual) > 0) ){ 
						map.put("entregas.status", BANDEIRA_VERMELHA);
						map.put("status", BANDEIRA_VERMELHA ); 
			} else if ( (dhAgendamentoEntrega != null) && (JTDateTimeUtils.getIntervalInHours(dhAgendamentoEntrega,horaAtual) > 0)){ 
							 map.put("entregas.status", BANDEIRA_VERMELHA);
							 map.put("status", BANDEIRA_VERMELHA );
			}else if ((vTotalEntregas > 0) && (vTotalEntregasBaixadas * 100 / vTotalEntregas) >= 50) {
					   map.put("entregas.status", BANDEIRA_AMARELA);
			} else {
				   map.put("entregas.status", BANDEIRA_BRANCA);
			}
			
			qtdColetasSemInteracao = countColetaSemInteracaoVOL(idMeioTransporte, tempEspVol);
			
			totalColetasSemInteracaoVol += qtdColetasSemInteracao;
			
			/* Status da coleta */
			if( qtdColetasSemInteracao > 0){
				map.put("coletas.status", BANDEIRA_AZUL);
			}else if (vTotalColetas.equals(vTotalColetasBaixadas)) {
				map.put("coletas.status", BANDEIRA_VERDE);
			} else if ( (dhAgendamentoColeta != null) && (JTDateTimeUtils.getIntervalInHours(dhAgendamentoColeta, horaAtual) > 0) ) {
						 map.put("coletas.status", BANDEIRA_VERMELHA);
						 map.put("status", BANDEIRA_VERMELHA );
			} else if ( ( dhAgendamentoColeta != null ) && (JTDateTimeUtils.getIntervalInHours(dhEventoColeta,horaAtual) > 0) ){
						   map.put("coletas.status", BANDEIRA_VERMELHA);
						   map.put("status", BANDEIRA_VERMELHA );
			} else if ((vTotalColetas > 0) && (vTotalColetasBaixadas * 100 / vTotalColetas) >= 50) {
			   map.put("coletas.status", BANDEIRA_AMARELA);
			} else {
			   map.put("coletas.status", BANDEIRA_BRANCA);	
			}
			
			if (vTotalEntregas.equals(vTotalEntregasBaixadas) && vTotalColetas.equals(vTotalColetasBaixadas)) {
				map.put("status", BANDEIRA_VERDE );
			}
			
			if (vQuantidadeChamadosFrota.longValue() > 0) {
			   map.put("status", IMAGEM_CELULAR );	
			   map.put("ligacoes", vQuantidadeChamadosFrota);
			   map.put("hr_ligacoes",JTFormatUtils.format(vPrimeiroChamadoFrota,"HH:mm"));
			}  
			
			map.put("entregas.manif", nrControleCarga);
			
			boolean inclui = true;
			
			// Possui filtros ativos não excludentes, ou seja, avaliar todos, positivo em algum, então deve ser apresentado.
			if ((tipoFrota.trim().length() > 0) || (tipoEntrega.trim().length() > 0) || (tipoColeta.trim().length() > 0)) {
				inclui = filtraSituacaoFrota(tipoFrota,map.getInteger("status")); 
				if (!inclui) {
					inclui = filtraSituacaoEntrega(tipoEntrega, map.getInteger("entregas.status"));
					if (!inclui) {
						inclui = filtraSituacaoColeta(tipoColeta, map.getInteger("coletas.status"));
					}
				}
			}
			
			if (inclui) {
			   if (! grupoFrota.equals(sGrupoFrota)) {
				  TypedFlatMap m = new TypedFlatMap();	
				  sGrupoFrota = grupoFrota;
				  m.put("quebra",sGrupoFrota);
				  result.add(m);
			   }
			   
			   
			totalEntregas += vTotalEntregas ;
			totalEntregasBaixadas += vTotalEntregasBaixadas;
			totalColetas += vTotalColetas;
			totalColetasBaixadas += vTotalColetasBaixadas;
			totalColetasAutomaticas += vTotalColetasAutomaticas;
		
			map.put("entregas.total", vTotalEntregas);
			map.put("entregas.reali", vTotalEntregasBaixadas);
			
			map.put("coletas.total", vTotalColetas);
			map.put("coletas.reali", vTotalColetasBaixadas);
			map.put("coletas.autom", vTotalColetasAutomaticas);
				map.put("totalColetasSemInteracaoVol", totalColetasSemInteracaoVol);
			
			map.put("eficiencia", this.getGerencialService().calculaEficiencia(vTotalEntregas, vTotalEntregasBaixadas, 
					vTotalColetas, vTotalColetasBaixadas, vTotalColetasAutomaticas) + "%");
			
			int frequencia = this.getGerencialService().calculaFrequencia(primeiraDhOcorrenciaEntrega,
					dhEventoColeta, horaAtual, ( vTotalEntregasBaixadas+vTotalColetasBaixadas ));
			if(frequencia > 0){
				totalFrotas++;
				totalFrequencia += frequencia;
			}
			
			map.put("frequencia", frequencia);
		    map.put("tratativas", vTotalTratativas);	
			map.put("idMeioTransporte",idMeioTransporte);
			map.put("idEquipamento",idEquipamento);
				map.put("dsNumero",dsNumero);
			map.put("frota",nrFrota + vNaoPossuiCelular + " " + nrIdentificador);
			map.put("meioTransporte2.nrFrota",nrFrota);
			map.put("meioTransporte.nrIdentificador",nrIdentificador);
			
			   total++;
			   result.add(map);	
			}
			
			//somente realiza a soma se a frota é exibida (incluída) na grid
			if ((vQuantidadeChamadosFrota.longValue() > 0) && (inclui)) {
				   ligacoesPendentes++;
			} 
		    
		}
		if (total > 0) {
			map = new TypedFlatMap();
			map.put("totais", "S");
			map.put("frota", total);
			map.put("entregas.reali", totalEntregasBaixadas);
			map.put("entregas.total", totalEntregas);
			map.put("coletas.autom", totalColetasAutomaticas);
			map.put("coletas.reali", totalColetasBaixadas);
			map.put("coletas.total", totalColetas);
			map.put("ligacoesPendentes", ligacoesPendentes);
			map.put("totalColetasSemInteracaoVol", totalColetasSemInteracaoVol);
			// eficiencia da frota
			map.put("eficiencia", this.getGerencialService().calculaEficiencia(
					(long) totalEntregas, (long) totalEntregasBaixadas,
					(long) totalColetas, (long) totalColetasBaixadas,
					(long) totalColetasAutomaticas)
					+ "%");
			// media das frequencias
			if (totalFrotas > 0) {
			   map.put("frequencia", (totalFrequencia / totalFrotas));
			} else {
			   map.put("frequencia", null);
			}

			result.add(map);
		} else {
			return java.util.Collections.EMPTY_LIST;
		}
 		
		return result;
	}
	
	
	/**
	 * @param tipoColeta
	 * @param map
	 * @param inclui
	 * @return
	 */
	private boolean filtraSituacaoColeta(String tipoColeta, int statusColeta) {
		final int BANDEIRA_BRANCA = 2;
		final int BANDEIRA_VERDE = 3;
		final int BANDEIRA_VERMELHA = 4;
		final int BANDEIRA_AMARELA = 5;

		boolean inclui = false;
		
		if (StringUtils.isNotBlank(tipoColeta)) {
			if ("C".equals(tipoColeta)) {
				if (statusColeta == BANDEIRA_VERDE) {
				   inclui = true;	
				}
			} else if ("M".equals(tipoColeta)) {
				if (statusColeta == BANDEIRA_AMARELA) {
				   inclui = true;	
				}
			} else if ("NI".equals(tipoColeta)) {
				if (statusColeta == BANDEIRA_VERMELHA){
					inclui = true;	
				}
			} else if ("N".equals(tipoColeta)) {
				if (statusColeta == BANDEIRA_BRANCA) {
				   inclui = true;	
				}
			}
		}
		return inclui;
	}

	/**
	 * @param tipoEntrega
	 * @param map
	 * @param inclui
	 * @return
	 */
	private boolean filtraSituacaoEntrega(String tipoEntrega, int statusEntrega) {
		final int BANDEIRA_BRANCA = 2;
		final int BANDEIRA_VERDE = 3;
		final int BANDEIRA_VERMELHA = 4;
		final int BANDEIRA_AMARELA = 5;
		
		boolean inclui = false;
		
		if (StringUtils.isNotBlank(tipoEntrega)) {
			if ("C".equals(tipoEntrega)) {
				if (statusEntrega == BANDEIRA_VERDE) {
					inclui = true;	
				}
			} else if ("M".equals(tipoEntrega)) {
				if (statusEntrega == BANDEIRA_AMARELA ) {
				   inclui = true;	
				}
			} else if ("NI".equals(tipoEntrega)) {
				if (statusEntrega == BANDEIRA_VERMELHA) {
				   inclui = true;	
				}
				
			} else if ("N".equals(tipoEntrega)) {
				if (statusEntrega == BANDEIRA_BRANCA) {
				   inclui = true;	
				}
			}
		}
		return inclui;
	}

	/**
	 * @param tipoFrota
	 * @param map
	 * @return
	 */
	private boolean filtraSituacaoFrota(String tipoFrota, int status) {
		final int IMAGEM_CELULAR = 1;
		final int BANDEIRA_BRANCA = 2;
		final int BANDEIRA_VERDE = 3;
		final int BANDEIRA_VERMELHA = 4;
		
		/* Filtro conforme valores informados nas combos */
		boolean inclui = false;
		if (StringUtils.isNotBlank(tipoFrota)) {
			if ("CH".equals(tipoFrota)) {
				if (status == IMAGEM_CELULAR) {
					inclui = true;	
				}
			} else if ("CHS".equals(tipoFrota)) {
				if (status == IMAGEM_CELULAR || status == BANDEIRA_VERMELHA) {
					inclui = true;	
				}
			} else if ("C".equals(tipoFrota)) {
				if (status == BANDEIRA_VERDE) {
					inclui = true;	
				}
			} else if ("S".equals(tipoFrota)) {
				if (status == BANDEIRA_VERMELHA) {
					inclui = true;	
				}
			} else if ("N".equals(tipoFrota)) {
				 if (status == BANDEIRA_BRANCA) {
				    inclui = true;	 
				 }
			}
		}
		return inclui;
	}

	/**
	 * @param result
	 */
	private void initMap(List result) {
		TypedFlatMap m1 = new TypedFlatMap();
		
		m1.put("idMeioTransporte","0");
		m1.put("status", "");
		m1.put("ligacoes", "");
		m1.put("hr_ligacoes", "");
		m1.put("hr_envio", "");
		m1.put("frota", "");
		m1.put("meioTransporte2.nrFrota", "");
		m1.put("meioTransporte.nrIdentificador", "");
		m1.put("evento", "");
		m1.put("tratativas", "");
		m1.put("entregas.status", "");
		m1.put("entregas.manif", "");
		m1.put("entregas.reali", "");
		m1.put("entregas.total", "");
		m1.put("coletas.status", "");
		m1.put("coletas.autom", "");
		m1.put("coletas.reali", "");
		m1.put("coletas.total", "");
		result.add(m1);
	}
	
	/**
	 * Busca o usuario da sessao e retorna para a tela
	 * 
	 * @return
	 */
	public Map findFilialUsuarioLogado() {

		Filial filial = SessionUtils.getFilialSessao();

		Map mapFilial = new HashMap();
		mapFilial.put("idFilial", filial.getIdFilial());
		mapFilial.put("sgFilial", filial.getSgFilial());

		Map mapPessoa = new HashMap();
		mapPessoa.put("nmFantasia", filial.getPessoa().getNmFantasia());
		mapFilial.put("pessoa", mapPessoa);

		Map mapSessionObjects = new HashMap();
		mapSessionObjects.put("filial", mapFilial);

		return mapSessionObjects;
	}
	
	
	public List findLookupFilialByEmpresa(TypedFlatMap map) {
    	Empresa empresa = (Empresa)SessionUtils.getEmpresasUsuarioLogado().get(0);
    	List result = getFilialService().findFilialBySgEmpresaLookup(map.getString("sgFilial"),empresa.getIdEmpresa());
    	List resultList = new ArrayList();
    	for (Iterator iter = result.iterator();iter.hasNext();) {
    		Map mapResult = (Map)iter.next();

    		TypedFlatMap tfm = new TypedFlatMap();
    		
    		tfm.put("idFilial", mapResult.get("idFilial"));
   		    tfm.put("sgFilial", mapResult.get("sgFilial"));
   		    tfm.put("pessoa.nmFantasia",mapResult.get("nmFantasia"));
    		
   		    resultList.add(tfm);
    	}
    	
    	return resultList;
    }

	public List findLookupFilialByUsuarioLogado(TypedFlatMap map) {
		List listFilial = this.filialService.findLookupByUsuarioLogado(map);
		
		if ( listFilial.isEmpty() ) {
			return listFilial;
		}
		
		List resultList = new ArrayList();
		
		Iterator iterator = listFilial.iterator();
		Map filial = (Map)iterator.next();
		TypedFlatMap typedFlatMap = new TypedFlatMap();
		typedFlatMap.put("idFilial", filial.get("idFilial") );
		typedFlatMap.put("pessoa.nmFantasia", filial.get("pessoa.nmFantasia") );
		typedFlatMap.put("sgFilial", filial.get("sgFilial") );
		resultList.add(typedFlatMap);
		
		return resultList;

	}
	
	public List findLookupGruposFrotas(Map map) {
		List result = getVolGruposFrotasService().findLookup(map);
		List resultList = new ArrayList();
		
		for (java.util.Iterator iter = result.iterator();iter.hasNext();) {
			TypedFlatMap resultMap = new TypedFlatMap();

			VolGruposFrotas gf = (VolGruposFrotas)iter.next();
			resultMap.put("idGrupoFrota", gf.getIdGrupoFrota());
			resultMap.put("dsNome", gf.getDsNome());
			resultMap.put("filial.idFilial", gf.getFilial().getIdFilial());
			resultMap.put("filial.sgFilial", gf.getFilial().getSgFilial());
			resultMap.put("filial.pessoa.nmFantasia", gf.getFilial().getPessoa().getNmFantasia());
			resultList.add(resultMap);
			
		}
		
		return resultList;
	}
	
	private List findColetasNaoExecutadas(Long idMeioTransporte){
		return this.gerencialService.findColetasNaoExecutadas(idMeioTransporte);
	}
	
	/**
	 * retorna as entregas não executadas e que possuem ou não agendamento de entrega
	 * @param idMeioTransporte
	 * @return
	 */
	private List findEntregasNaoExecutadasComAgendamento(Long idMeioTransporte){
		return this.gerencialService.findEntregasNaoExecutadasComAgendamento(idMeioTransporte);
	}
	
	private boolean verificaExitenciaAgendamentoEntrega(List list){
		Iterator iterator = list.iterator();
		
		if(list.isEmpty()){ 
			return false;
		} else {
			while (iterator.hasNext()) {
				Map linha = (Map) iterator.next();
				
				if ( linha.get("hrPreferenciaInicial") == null) {
					return false;
				}
			}
		}
		
		return true;
	}
	
	/**
	 * verifica se dentre as coletas não realizadas qual/quais possui ou não agendamento 
	 * @param list
	 * @return
	 * TODO verificar se em produção realmente existe a possibilidade  retornar uma list
	 */
	private Boolean verificaExistenciaAgendamentoColeta(List list){
		Iterator iterator = list.iterator();
		
		if(list.isEmpty()){
			return false;
		} else {
			while (iterator.hasNext()) {
				Map linha = (Map) iterator.next();
				
				if (linha.get("dhColetaDisponivel") == null ){
					return false;
				} 
			}
		}
		return true;
	}
	
	/**
	 * converte a horaAtual e a hrPreferenciaInicial para inteiro. Esse método foi necessário pois a hrPreferenciaInicial
	 * retornada do banco é um TimeOfDay. 
	 * @param hora
	 * @return
	 */
	private int converteHoraParaInteiro(String hora){
		String horaFormatada = "";
		String[] horaFormatadaTemp = hora.split(":");
		
		if(horaFormatadaTemp[0].startsWith("T")){
			horaFormatadaTemp[0] = horaFormatadaTemp[0].replace(horaFormatadaTemp[0], horaFormatadaTemp[0].substring(1));
			for (int i = 0; i < horaFormatadaTemp.length - 1; i++){
				horaFormatada = horaFormatada + horaFormatadaTemp[i];
			}
		}else {
			for (int i = 0; i < horaFormatadaTemp.length; i++){
				horaFormatada = horaFormatada + horaFormatadaTemp[i];
			}
		}
		return Integer.parseInt(horaFormatada);
	}
	
	/**
	 * calcula a diferença entre a horaAtual e hrPreferenciaInicial
	 * @param horaAtual
	 * @param horaBanco
	 * @return
	 */
	private int calculaIntervaloEmHoras(int horaAtual, int horaBanco){
		return horaAtual - horaBanco;
	}
	
	private int countColetaSemInteracaoVOL(Long idMeioTransporte, int tempEspVol){
		int qtdColetasSemInteracao = 0;   
		List<EventoColeta> eventoColetaList = eventoColetaService.findEventoTransmitidoByMeioTransporte(idMeioTransporte);
		
		for(EventoColeta eventoColeta : eventoColetaList){
			DateTime dhEventoColetaTransmitida = eventoColeta.getDhEvento();
			DateTime dhAtual = JTDateTimeUtils.getDataHoraAtual(SessionUtils.getFilialSessao());
			
			Duration duration = new Duration(dhEventoColetaTransmitida, dhAtual);
			long diferenca = duration.getMillis();
			
			if( diferenca > tempEspVol * 60 * 1000){
				qtdColetasSemInteracao++;
			}
			
		}
		
		return qtdColetasSemInteracao;
		
	}
	
	public FilialService getFilialService() {
		return filialService;
	}

	public void setFilialService(FilialService filialService) {
		this.filialService = filialService;
	}

	public VolGruposFrotasService getVolGruposFrotasService() {
		return volGruposFrotasService;
	}

	public void setVolGruposFrotasService(
			VolGruposFrotasService volGruposFrotasService) {
		this.volGruposFrotasService = volGruposFrotasService;
	}
	
	public VolEquipamentosService getVolEquipamentosService() {
		return volEquipamentosService;
	}

	public void setVolEquipamentosService(
			VolEquipamentosService volEquipamentosService) {
		this.volEquipamentosService = volEquipamentosService;
	}

	public VolAvisoPendenciaService getVolAvisoPendenciaService() {
		return volAvisoPendenciaService;
	}

	public void setVolAvisoPendenciaService(
			VolAvisoPendenciaService volAvisoPendenciaService) {
		this.volAvisoPendenciaService = volAvisoPendenciaService;
	}

	public void setEventoColetaService(EventoColetaService eventoColetaService) {
		this.eventoColetaService = eventoColetaService;
}

	public void setParametroGeralService(ParametroGeralService parametroGeralService) {
		this.parametroGeralService = parametroGeralService;
	}
}
