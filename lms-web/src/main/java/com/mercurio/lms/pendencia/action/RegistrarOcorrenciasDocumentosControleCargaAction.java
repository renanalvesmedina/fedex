package com.mercurio.lms.pendencia.action;

import com.mercurio.adsm.framework.BusinessException;
import com.mercurio.adsm.framework.model.CrudAction;
import com.mercurio.adsm.framework.model.DomainValue;
import com.mercurio.adsm.framework.model.FindDefinition;
import com.mercurio.adsm.framework.model.ResultSetPage;
import com.mercurio.adsm.framework.model.hibernate.VarcharI18n;
import com.mercurio.adsm.framework.model.service.DomainValueService;
import com.mercurio.adsm.framework.util.TypedFlatMap;
import com.mercurio.lms.carregamento.model.ControleCarga;
import com.mercurio.lms.carregamento.model.service.CarregamentoDescargaService;
import com.mercurio.lms.carregamento.model.service.ControleCargaService;
import com.mercurio.lms.configuracoes.ConfiguracoesFacade;
import com.mercurio.lms.expedicao.model.DoctoServico;
import com.mercurio.lms.expedicao.model.service.DoctoServicoService;
import com.mercurio.lms.expedicao.util.ConstantesExpedicao;
import com.mercurio.lms.municipios.model.service.FilialService;
import com.mercurio.lms.pendencia.model.service.OcorrenciaDoctoServicoService;
import com.mercurio.lms.sim.ConstantesSim;
import com.mercurio.lms.sim.model.service.EventoDocumentoServicoService;
import com.mercurio.lms.util.session.SessionUtils;
import org.hibernate.criterion.ProjectionList;
import org.hibernate.criterion.Projections;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;


/**
 * Generated by: ADSM ActionGenerator
 * <p>
 * Não inserir documentação após ou remover a tag do XDoclet a seguir.
 * O valor do <code>id</code> informado abaixo deve ser utilizado para referenciar este serviço.
 *
 * @spring.bean id="lms.pendencia.registrarOcorrenciasDocumentosControleCargaAction"
 */

public class RegistrarOcorrenciasDocumentosControleCargaAction extends CrudAction {

    private static final String MANIFESTO_BL_BLOQUEADO = "manifesto.blBloqueado";
    private static final String ID_DOCTO_SERVICO = "idDoctoServico";
    private static final String TP_DOCUMENTO_SERVICO = "tpDocumentoServico";
    private static final String MANIFESTO_TP_MANIFESTO_VALUE = "manifesto.tpManifesto.value";
    private static final String MANIFESTO_ID_MANIFESTO = "manifesto.idManifesto";
    private static final String BL_BLOQUEADO = "blBloqueado";
    private static final String ID_FILIAL_DESTINO = "idFilialDestino";
    private static final String SG_FILIAL_DESTINO = "sgFilialDestino";
    private static final String DS_SIMBOLO = "dsSimbolo";
    private static final String SG_MOEDA = "sgMoeda";
    private static final String VL_TOTAL_MANIFESTO = "vlTotalManifesto";
    private static final String DM_STATUS_MANIFESTO_COLETA = "DM_STATUS_MANIFESTO_COLETA";
    private static final String TP_STATUS_MANIFESTO = "tpStatusManifesto";
    private static final String TP_MANIFESTO = "tpManifesto";
    private static final String BL_MATRIZ = "blMatriz";
    private static final String ERROR = "error";
    private static final String MANIFESTO_TP_STATUS_MANIFESTO_VALUE = "manifesto.tpStatusManifesto.value";
    private static final String DS_ID = "ds.id";
    private static final String DS_TP_DOCUMENTO_SERVICO = "ds.tpDocumentoServico";
    private static final int POS_6 = 6;
    private static final int POS_7 = 7;
    private static final int POS_8 = 8;
    private static final int POS_9 = 9;
    private static final int POS_10 = 10;
    private static final int POS_11 = 11;
    private static final int POS_5 = 5;
    private static final int POS_3 = 3;
    private static final int POS_2 = 2;
    private static final int POS_1 = 1;
    private static final int POS_0 = 0;
    private static final int POS_4 = 4;
    private static final String DM_TIPO_MANIFESTO = "DM_TIPO_MANIFESTO";
    private static final String DM_STATUS_MANIFESTO = "DM_STATUS_MANIFESTO";
    private static final String COLETA = "Coleta";
    private OcorrenciaDoctoServicoService ocorrenciaDoctoServicoService;
	private FilialService filialService;
	private ControleCargaService controleCargaService;
	private CarregamentoDescargaService carregamentoDescargaService;
	private EventoDocumentoServicoService eventoDocumentoServicoService;
	private DoctoServicoService doctoServicoService;
	private ConfiguracoesFacade configuracoesFacade;
	private DomainValueService domainValueService;
	
	
	public FilialService getFilialService() {
		return filialService;
	}

	public void setFilialService(FilialService filialService) {
		this.filialService = filialService;
	}

	public ControleCargaService getControleCargaService() {
		return controleCargaService;
	}

	public void setControleCargaService(ControleCargaService controleCargaService) {
		this.controleCargaService = controleCargaService;
	}

	public CarregamentoDescargaService getCarregamentoDescargaService() {
		return carregamentoDescargaService;
	}

	public void setCarregamentoDescargaService(CarregamentoDescargaService carregamentoDescargaService) {
		this.carregamentoDescargaService = carregamentoDescargaService;
	}

	public EventoDocumentoServicoService getEventoDocumentoServicoService() {
		return eventoDocumentoServicoService;
	}

	public void setEventoDocumentoServicoService(EventoDocumentoServicoService eventoDocumentoServicoService) {
		this.eventoDocumentoServicoService = eventoDocumentoServicoService;
	}

	public DoctoServicoService getDoctoServicoService() {
		return doctoServicoService;
	}

	public void setDoctoServicoService(DoctoServicoService doctoServicoService) {
		this.doctoServicoService = doctoServicoService;
	}

	public ConfiguracoesFacade getConfiguracoesFacade() {
		return configuracoesFacade;
	}

	public void setConfiguracoesFacade(ConfiguracoesFacade configuracoesFacade) {
		this.configuracoesFacade = configuracoesFacade;
	}

	public DomainValueService getDomainValueService() {
		return domainValueService;
	}

	public void setDomainValueService(DomainValueService domainValueService) {
		this.domainValueService = domainValueService;
	}	

	
	public List findLookupBySgFilial(TypedFlatMap criteria) {
		return this.getFilialService().findLookupBySgFilial((String)criteria.get("sgFilial"), (String)criteria.get("tpAcesso"));
	}
	
	/**
	 * Busca um controle de carga
	 */
	public List findControleCargaByNrControleByFilial(TypedFlatMap criteria) {
		Long nrControleCarga = criteria.getLong("nrControleCarga");
		Long idFilial = criteria.getLong("filialByIdFilialOrigem.idFilial");
		return this.getControleCargaService().findControleCargaByNrControleByFilial(nrControleCarga, idFilial);
	}	
	
	/**
	 * ResultSetPage de Manifestos
     *
	 * @param criteria
	 * @return
	 */
    public ResultSetPage findPaginatedManifesto(TypedFlatMap criteria) {

    	Long idControleCarga = criteria.getLong("controleCarga.idControleCarga");
    	String tpControleCarga = criteria.getString("controleCarga.tpControleCarga.value");

    	ResultSetPage rsp = this.getCarregamentoDescargaService().findPaginatedManifestoViagemEntregaByIdControleCarga(idControleCarga, tpControleCarga, null, FindDefinition.createFindDefinition(criteria));
    	
		List listManifestos = new ArrayList();
        for (int i = POS_0; i < rsp.getList().size(); i++) {
    		Object[] objResult = (Object[]) rsp.getList().get(i);
    		TypedFlatMap mapResult = mountMapByObject(objResult);
    		//Adição de um idCustom.
    		mapResult.put("idCustom", i);
    		listManifestos.add(mapResult);
		}	
	
		rsp.setList(listManifestos);

		return rsp;
    }

    /**
     * Quantidade de manifestos do ResultSetPage
     *
     * @param criteria
     * @return
     */
    public Integer getRowCountManifesto(TypedFlatMap criteria) {
    	Long idControleCarga = criteria.getLong("controleCarga.idControleCarga");
    	String tpControleCarga = criteria.getString("controleCarga.tpControleCarga.value");
		return this.getCarregamentoDescargaService().getRowCountManifestoViagemEntregaByIdControleCarga(idControleCarga, tpControleCarga, null);
    }
    
	/**
	 * Método que monta um map a partir do Objeto.
     *
	 * @param objResult
	 * @return
	 */
	private TypedFlatMap mountMapByObject(Object[] objResult) {
		TypedFlatMap mapResult = new TypedFlatMap();
        mapResult.put("idManifesto", objResult[POS_0]);
        mapResult.put("sgFilialOrigem", objResult[POS_1]);
        mapResult.put("nrManifesto", objResult[POS_2]);
        mapResult.put("dhGeracaoPreManifesto", objResult[POS_3]);
		
        if (objResult[POS_4] != null) {
			DomainValue domainValue1 = this.getDomainValueService().
                    findDomainValueByValue(DM_TIPO_MANIFESTO, objResult[POS_4].toString());
            mapResult.put(TP_MANIFESTO, new DomainValue(domainValue1.getValue(), domainValue1.getDescription(),
														 domainValue1.getStatus()));
			
			DomainValue domainValue2 = this.getDomainValueService().
                    findDomainValueByValue(DM_STATUS_MANIFESTO, objResult[POS_5].toString());
            mapResult.put(TP_STATUS_MANIFESTO, new DomainValue(domainValue2.getValue(), domainValue2.getDescription(),
								   							   domainValue2.getStatus())); 
		} else {
            mapResult.put(TP_MANIFESTO, new DomainValue("C", new VarcharI18n(COLETA), Boolean.TRUE));
			
			DomainValue domainValue2 = this.getDomainValueService().
                    findDomainValueByValue(DM_STATUS_MANIFESTO_COLETA, objResult[POS_5].toString());
            mapResult.put(TP_STATUS_MANIFESTO, new DomainValue(domainValue2.getValue(), domainValue2.getDescription(),
															   domainValue2.getStatus()));				
		}
		
        if (objResult[POS_6] != null) {
            if ("N".equals(objResult[POS_6].toString())) {
                mapResult.put(BL_BLOQUEADO, Boolean.FALSE);
			} else {
                mapResult.put(BL_BLOQUEADO, Boolean.TRUE);
			}			
		} else {
            mapResult.put(BL_BLOQUEADO, objResult[POS_6]);
		}
        mapResult.put(ID_FILIAL_DESTINO, objResult[POS_7]);
        mapResult.put(SG_FILIAL_DESTINO, objResult[POS_8]);
        mapResult.put(DS_SIMBOLO, objResult[POS_9]);
        mapResult.put(SG_MOEDA, objResult[POS_10]);
        mapResult.put(VL_TOTAL_MANIFESTO, objResult[POS_11]);
		
		return mapResult;
	} 	    
    
	/**
	 * Pega o usuario logado na sessão com sua moeda e sua respectiva filial. 
	 */
	public TypedFlatMap getDadosSessao() {
		TypedFlatMap map = new TypedFlatMap();
		// Verifica se a filial em questão é uma Matriz.
		Boolean blMatriz = Boolean.valueOf(SessionUtils.isFilialSessaoMatriz());
        map.put(BL_MATRIZ, blMatriz);
		return map;
	}	    
    
	/**
	 * Método que valida o Manifesto.
     *
	 * @param criteria
	 * @return
	 */
	public TypedFlatMap validacaoManifesto(TypedFlatMap criteria) {
		TypedFlatMap map = new TypedFlatMap();
		map.put("rowIndex", criteria.getString("rowIndex"));
		
		// Verifica os status dos manifestos selecionados.
		List listManifestos = criteria.getList("listManifestos");	
        if (validaSeListaDeManifestosNaoFOrNula(criteria, map, listManifestos)){
					return map;					
				}	
		
		// Verifica se o manifesto está com o status 'FECHADO'. Caso sim, o manifesto não pode ser bloqueado.
        if ("FE".equals(criteria.getString(MANIFESTO_TP_STATUS_MANIFESTO_VALUE))) {
            map.put(ERROR, this.getConfiguracoesFacade().getMensagem("LMS-17025"));
			return map;
		}
		
		/** Otimização */
		final ProjectionList projection = Projections.projectionList()
                .add(Projections.property(DS_ID), ID_DOCTO_SERVICO)
                .add(Projections.property(DS_TP_DOCUMENTO_SERVICO), TP_DOCUMENTO_SERVICO);
		// Verifica se algum documento do manifesto já foi entregue. Caso sim, o manifesto não pode ser bloqueado nem liberado.
		
        boolean isManifestoEntrega = ConstantesExpedicao.TP_MANIFESTO_ENTREGA.equals(criteria.getString(MANIFESTO_TP_MANIFESTO_VALUE));
		
        final List<DoctoServico> doctoServicoList = doctoServicoService.findDoctoServicoByIdManifesto(criteria.getLong(MANIFESTO_ID_MANIFESTO), projection);

        List<Long> doctoServicoIds = new ArrayList<Long>();

		for (DoctoServico doctoServico : doctoServicoList) {

            doctoServicoIds.add(doctoServico.getIdDoctoServico());

			if(!ConstantesExpedicao.MINUTA_DESPACHO_ACOMPANHAMENTO.equals(doctoServico.getTpDocumentoServico().getValue())){
                map.put(ID_DOCTO_SERVICO, doctoServico.getIdDoctoServico());
				
				List eventos = this.getEventoDocumentoServicoService().findEventoDoctoServico(doctoServico.getIdDoctoServico(), ConstantesSim.EVENTO_ENTREGA);
                if (eventos != null && !eventos.isEmpty()) {
					//Manifesto não pode ser bloqueado/liberado pois possui documento já entregue.
                    map.put(ERROR, this.getConfiguracoesFacade().getMensagem("LMS-17026"));
					return map;
				}
				
                if (verificaExistenciaDocumentoDeServicoSeManifestoEntrega(map, isManifestoEntrega, doctoServico)) {
						return map;
					}
				}
			}
		
        alterarIdPadraoPeloSeExistemOcorrencias(criteria, map, doctoServicoIds);

		return map;
	}

    private void alterarIdPadraoPeloSeExistemOcorrencias(TypedFlatMap criteria, TypedFlatMap map, List<Long> doctoServicoIds) {
        List<Long> blockedIds = ocorrenciaDoctoServicoService.findSimplifiedOcorrenciaDoctoServicoEmAbertoByIdsDoctoServico(doctoServicoIds);
        if (!blockedIds.isEmpty()) {
            if (criteria.getBoolean(MANIFESTO_BL_BLOQUEADO)) {
                map.put(ID_DOCTO_SERVICO, blockedIds.get(POS_0));
            } else {
                doctoServicoIds.removeAll(blockedIds);
                if (!blockedIds.isEmpty()) {
                    map.put(ID_DOCTO_SERVICO, doctoServicoIds.get(POS_0));
                }
            }
        }
    }
	
    private boolean validaSeListaDeManifestosNaoFOrNula(TypedFlatMap criteria, TypedFlatMap map, List listManifestos) {
        if (listManifestos != null) {
            for (Iterator iter = listManifestos.iterator(); iter.hasNext(); ) {
                TypedFlatMap mapManifestos = (TypedFlatMap) iter.next();

                //Para os manifestos selecionados,
                boolean blBloqueadoAnterior = mapManifestos.getBoolean(MANIFESTO_BL_BLOQUEADO);
                boolean blBloqueadoNovo = criteria.getBoolean(MANIFESTO_BL_BLOQUEADO);
                if (blBloqueadoAnterior && blBloqueadoNovo) {
                    //Somente um Manifesto bloqueado pode ser liberado por vez.
                    map.put(ERROR, this.getConfiguracoesFacade().getMensagem("LMS-17030"));
                    return true;
                }
                if (blBloqueadoAnterior != blBloqueadoNovo) {
                    //Os Manifestos selecionados devem estar no mesmo status.
                    map.put(ERROR, this.getConfiguracoesFacade().getMensagem("LMS-17029"));
                    return true;
                }
            }
        }
        return false;
    }

    private boolean verificaExistenciaDocumentoDeServicoSeManifestoEntrega(TypedFlatMap map, boolean isManifestoEntrega, DoctoServico doctoServico) {
        if (isManifestoEntrega) {
            List eventos = this.getEventoDocumentoServicoService().findEventoDoctoServico(doctoServico.getIdDoctoServico(), ConstantesSim.EVENTO_ENTREGA_REALIZADA_AEROPORTO);
            if (eventos != null && !eventos.isEmpty()) {
                //Manifesto não pode ser bloqueado/liberado pois possui documento já entregue no aeroporto.
                map.put(ERROR, this.getConfiguracoesFacade().getMensagem("LMS-17051"));
                return true;
            }
        }
        return false;
    }


	public void validateControleCarga(TypedFlatMap map) {
		Long idControleCarga = map.getLong("idControleCarga");
		ControleCarga cc = controleCargaService.findByIdInitLazyProperties(idControleCarga, false);
		
        if (("V".equals(cc.getTpControleCarga().getValue()) && !"EV".equals(cc.getTpStatusControleCarga().getValue())) ||
                ("C".equals(cc.getTpControleCarga().getValue()) && !"TC".equals(cc.getTpStatusControleCarga().getValue()))) {
			throw new BusinessException("LMS-17043");
		}
	}

    public void setOcorrenciaDoctoServicoService(OcorrenciaDoctoServicoService ocorrenciaDoctoServicoService) {
        this.ocorrenciaDoctoServicoService = ocorrenciaDoctoServicoService;
    }
}