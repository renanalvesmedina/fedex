package com.mercurio.lms.municipios.action;

import java.io.Serializable;
import java.math.BigDecimal;
import java.text.Collator;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.collections.MapUtils;
import org.joda.time.TimeOfDay;
import org.joda.time.YearMonthDay;
import org.springframework.context.i18n.LocaleContextHolder;

import com.mercurio.adsm.core.util.ReflectionUtils;
import com.mercurio.adsm.framework.BusinessException;
import com.mercurio.adsm.framework.annotations.ParametrizedAttribute;
import com.mercurio.adsm.framework.model.DomainValue;
import com.mercurio.adsm.framework.model.ResultSetPage;
import com.mercurio.adsm.framework.model.masterdetail.ItemList;
import com.mercurio.adsm.framework.model.masterdetail.ItemListConfig;
import com.mercurio.adsm.framework.model.masterdetail.MasterDetailAction;
import com.mercurio.adsm.framework.model.masterdetail.MasterDetailFactory;
import com.mercurio.adsm.framework.model.masterdetail.MasterDetailKey;
import com.mercurio.adsm.framework.model.masterdetail.MasterEntry;
import com.mercurio.adsm.framework.model.masterdetail.MasterEntryConfig;
import com.mercurio.adsm.framework.util.FilterResultSetPage;
import com.mercurio.adsm.framework.util.TypedFlatMap;
import com.mercurio.lms.configuracoes.ConfiguracoesFacade;
import com.mercurio.lms.configuracoes.model.MoedaPais;
import com.mercurio.lms.configuracoes.model.ParametroGeral;
import com.mercurio.lms.configuracoes.model.Pessoa;
import com.mercurio.lms.configuracoes.model.Servico;
import com.mercurio.lms.configuracoes.model.service.ParametroGeralService;
import com.mercurio.lms.configuracoes.model.service.ServicoService;
import com.mercurio.lms.contratacaoveiculos.model.TipoMeioTransporte;
import com.mercurio.lms.contratacaoveiculos.model.service.TipoMeioTransporteService;
import com.mercurio.lms.municipios.model.Filial;
import com.mercurio.lms.municipios.model.FilialRota;
import com.mercurio.lms.municipios.model.FluxoFilial;
import com.mercurio.lms.municipios.model.Pais;
import com.mercurio.lms.municipios.model.Rota;
import com.mercurio.lms.municipios.model.RotaIdaVolta;
import com.mercurio.lms.municipios.model.RotaViagem;
import com.mercurio.lms.municipios.model.ServicoRotaViagem;
import com.mercurio.lms.municipios.model.TrechoRotaIdaVolta;
import com.mercurio.lms.municipios.model.service.FilialRotaService;
import com.mercurio.lms.municipios.model.service.FilialService;
import com.mercurio.lms.municipios.model.service.FluxoFilialService;
import com.mercurio.lms.municipios.model.service.PontoParadaTrechoService;
import com.mercurio.lms.municipios.model.service.RotaService;
import com.mercurio.lms.municipios.model.service.RotaViagemService;
import com.mercurio.lms.municipios.model.service.ServicoRotaViagemService;
import com.mercurio.lms.municipios.model.service.TrechoRotaIdaVoltaService;
import com.mercurio.lms.util.BigDecimalUtils;
import com.mercurio.lms.util.CompareUtils;
import com.mercurio.lms.util.FormatUtils;
import com.mercurio.lms.util.IntegerUtils;
import com.mercurio.lms.util.JTDateTimeUtils;
import com.mercurio.lms.util.JTFormatUtils;
import com.mercurio.lms.util.JTVigenciaUtils;
import com.mercurio.lms.util.LongUtils;
import com.mercurio.lms.util.session.SessionUtils;
import com.mercurio.lms.vendas.model.Cliente;
import com.mercurio.lms.vendas.model.service.ClienteService;

/**
 * Generated by: ADSM ActionGenerator
 * 
 * Não inserir documentação após ou remover a tag do XDoclet a seguir.
 * O valor do <code>id</code> informado abaixo deve ser utilizado para referenciar este serviço.
 * @spring.bean id="lms.municipios.manterRotasViagemAction"
 */
public class ManterRotasViagemAction extends MasterDetailAction {
	private FilialService filialService;	
	private ServicoService servicoService;
	private ServicoRotaViagemService servicoRotaViagemService;
	private RotaService rotaService;
	private TrechoRotaIdaVoltaService trechoRotaIdaVoltaService;
	private FilialRotaService filialRotaService;
	private ConfiguracoesFacade configuracoesFacade;
	private TipoMeioTransporteService tipoMeioTransporteService;
	private ClienteService clienteService;
	private FluxoFilialService fluxoFilialService;
	private PontoParadaTrechoService pontoParadaTrechoService;
	private ParametroGeralService parametroGeralService;

	/**
	 * FindById retorna um Map com valor de 'Frete Carreteiro' e 'Número Ação Vigência'
	 * @param id
	 * @return Map 
	 */
	public Map findByIdRotaViagem(Long id) {
		// Consulta informações básicas de uma rota viagem.
		RotaViagem rotaViagem = getRotaViagemService().findById(id);
		// Coloca pojo na seção (característica DF2).
		putMasterInSession(rotaViagem);
		// Instância de TypedFlatMap, para retornar dados para a aba de detalhamento.
		TypedFlatMap result = new TypedFlatMap();

		// Carrega informações básicas da rotaViagem no Map.
		result.put("idRotaViagem",rotaViagem.getIdRotaViagem());
		result.put("versao",rotaViagem.getVersao());
		result.put("dtVigenciaInicial",rotaViagem.getDtVigenciaInicial());
		result.put("dtVigenciaFinal",rotaViagem.getDtVigenciaFinal());
		// Se rotaViagem tem tipo meio de transporte, coloca no Map.				
		TipoMeioTransporte tipoMeioTransporte = rotaViagem.getTipoMeioTransporte();
		if (tipoMeioTransporte != null) {
			result.put("tipoMeioTransporte.idTipoMeioTransporte",tipoMeioTransporte.getIdTipoMeioTransporte());
			result.put("tipoMeioTransporte.dsTipoMeioTransporte",tipoMeioTransporte.getDsTipoMeioTransporte());
		}
		// Se rotaViagem tem cliente, coloca no Map.
		Cliente cliente = rotaViagem.getCliente();
		if (cliente != null) {
			result.put("cliente.idCliente",cliente.getIdCliente());
			Pessoa pessoaCliente = cliente.getPessoa();
			result.put("cliente.pessoa.nrIdentificacao",pessoaCliente.getNrIdentificacao());
			result.put("cliente.pessoa.nrIdentificacaoFormatado",
					FormatUtils.formatIdentificacao(pessoaCliente.getTpIdentificacao(),pessoaCliente.getNrIdentificacao()));
			result.put("cliente.pessoa.nmPessoa",pessoaCliente.getNmPessoa());
		}
		// É necessário desmembrar o domínio tpRota. 
		result.put("tpRota.value",rotaViagem.getTpRota().getValue());
		result.put("tpRota.status",rotaViagem.getTpRota().getStatus());
		result.put("tpRota.description",rotaViagem.getTpRota().getDescription().getValue(LocaleContextHolder.getLocale()));
		// É necessário desmembrar o domínio tpSistemaRota.
		// Rota Eventual não possui Sistema da Rota! 
		if (rotaViagem.getTpSistemaRota() != null) {
			result.put("tpSistemaRota.value",rotaViagem.getTpSistemaRota().getValue());
			result.put("tpSistemaRota.status",rotaViagem.getTpSistemaRota().getStatus());
			result.put("tpSistemaRota.description",rotaViagem.getTpSistemaRota().getDescription());
		}

		// Maps onde será carregado informações da Rota Ida e Rota Volta.
		Map oldMapIdaEvent = null;
		Map oldMapVolta = null;
		// Chave auxiliar para manipular os Maps.
		String rotaKey = null;

		// Ao detalhar uma rota expressa, deve criar um map de Rota Ida.
		oldMapIdaEvent = getRotaViagemService().findByIdDetalhamentoRota(id,"I");
		rotaKey = "rotaIda.";
		oldMapVolta = getRotaViagemService().findByIdDetalhamentoRota(id,"V");

		Iterator i = null;
		// Set o qual manterá todas as chaves do Map oldMapIdaEvent.
		Set set = oldMapIdaEvent.keySet();

		for (i = set.iterator(); i.hasNext();) {
			String key = ((String)i.next());
			if (key.indexOf("tpRotaIdaVolta") != -1)
				result.put(rotaKey.concat("tpRotaIdaVolta"),((DomainValue)oldMapIdaEvent.get(key)).getValue());
			else
				result.put(rotaKey.concat(key.replace('_','.')),oldMapIdaEvent.get(key));				
		}
		// Carrega as filiais que serão apresentadas na listBox de Rota Ida (ou Eventual) no detalhamento. 
		result.put(rotaKey.concat("filiaisRota"),this.filialRotaService.findFiliaisRotaByRota(result.getLong(rotaKey.concat("idRota"))));

		// Encontra o tempo de viagem do trecho q vai da filial origem até a filial destino da rota.
		Integer nrTempo = getRotaViagemService().findMaiorTempoViagemOfRota((Long)oldMapIdaEvent.get("idRotaIdaVolta"));
		String nrTempoViagem = FormatUtils.converteMinutosParaHorasMinutos(
					Long.valueOf(nrTempo.longValue()),FormatUtils.ESCALA_HHH);
		result.put(rotaKey.concat("nrTempoViagem"),nrTempoViagem);

		// Se é uma rota Eventual, devemos retornar a Rota Volta.

		if (oldMapVolta != null) {
			Long idRota = (Long)oldMapVolta.get("idRota");
			if (idRota != null) {
				// Set o qual manterá todas as chaves do Map oldMapVolta.
				set = oldMapVolta.keySet();

				for (i = set.iterator(); i.hasNext();) {
					String key = ((String)i.next());
					// Se a chave conter 'tpRotaIdaVolta', então carrega apenas o 'value' do domínio.
					if (key.indexOf("tpRotaIdaVolta") != -1)
						result.put("rotaVolta.tpRotaIdaVolta",((DomainValue)oldMapVolta.get(key)).getValue());
					else
						result.put("rotaVolta.".concat(key.replace('_','.')),oldMapVolta.get(key));					
				}
				// Carrega as filiais que serão apresentadas na listBox de Rota Volta no detalhamento.
				result.put("rotaVolta.filiaisRota",this.filialRotaService.findFiliaisRotaByRota(idRota));
				nrTempo = getRotaViagemService().findMaiorTempoViagemOfRota((Long)oldMapVolta.get("idRotaIdaVolta"));
				nrTempoViagem = FormatUtils.converteMinutosParaHorasMinutos(
							Long.valueOf(nrTempo.longValue()),FormatUtils.ESCALA_HHH);
					result.put("rotaVolta.".concat("nrTempoViagem"),nrTempoViagem);
			}			
		}

		BigDecimal vlPedagio = null;
		if (tipoMeioTransporte != null) {
			Long idMoedaPais = result.getLong("rotaIda.moedaPais.idMoedaPais");
			Long idRotaIda = result.getLong("rotaIda.idRota");
			if (idMoedaPais != null && idRotaIda != null) {
				vlPedagio = getRotaViagemService().findVlPedagio(idMoedaPais,tipoMeioTransporte.getIdTipoMeioTransporte(),idRotaIda);
				result.put("rotaIda.vlPedagio",vlPedagio);
			}

			idMoedaPais = result.getLong("rotaVolta.moedaPais.idMoedaPais");
			Long idRotaVolta = result.getLong("rotaVolta.idRota");
			if (idMoedaPais != null && idRotaVolta != null) {
				vlPedagio = getRotaViagemService().findVlPedagio(idMoedaPais,tipoMeioTransporte.getIdTipoMeioTransporte(),idRotaVolta);
				result.put("rotaVolta.vlPedagio",vlPedagio);
			}
		}		

		// É necessário carregar a descrição de tpRota, pois será usada nos linkProperties.
		result.put("dsTpRota",rotaViagem.getTpRota().getDescription());

		// Antes de retornar, é necessário colocar no map o numero de ação vigência.
		// É somado um dia na vigência inicial para se poder alterar um registro detalhado que inicia vigência no próprio dia.
		Integer integerAcaoVigencia = JTVigenciaUtils.getIntegerAcaoVigencia(rotaViagem.getDtVigenciaInicial().plusDays(1),
				rotaViagem.getDtVigenciaFinal());
		if (integerAcaoVigencia != 0 && integerAcaoVigencia != 1) {
			if (!getRotaViagemService().findRotaViagemFutura(id, rotaViagem.getDtVigenciaFinal())) {
				integerAcaoVigencia = 1;
			}
		}
		result.put("acaoVigenciaAtual",integerAcaoVigencia);

		return result;
	}

	/**
	 * Retorna lista com todos os registros encotrados a partir dos filtros.
	 * @param filtros
	 * @return
	 */
	public ResultSetPage findPaginatedRotaViagem(TypedFlatMap filtros) {
		return getRotaViagemService().findPaginatedRotaViagem(filtros);
	}

	/**
	 * Retorna contagem de todos os registros encotrados a partir dos filtros.
	 * @param criteria
	 * @return
	 */
	public Integer getRowCountRotaViagem(TypedFlatMap criteria) {
		return getRotaViagemService().getRowCountRotaViagem(criteria);
	}

	/**
	 * Valida datas de vigência e retorna uma BusinessException se for uma inclusão.
	 * Esta excessão será apresentada ao usuário como uma confirmação.
	 * @param bean
	 * @return Map quando for alteração, retornando ids e campos gerados ao salvar.
	 */
	public Map storeValidation(TypedFlatMap bean) {
		// Objetos auxiliares carregam datas de vigência:
		Long idRotaViagem = bean.getLong("idRotaViagem");
		YearMonthDay dtVigenciaInicial = bean.getYearMonthDay("dtVigenciaInicial");
		YearMonthDay dtVigenciaFinal = bean.getYearMonthDay("dtVigenciaFinal");

		// realiza validação de vigência padrão e não atribui serviços, chamando STORE! 
		RotaViagem rv = new RotaViagem();
		rv.setIdRotaViagem(idRotaViagem);
		rv.setDtVigenciaInicial(dtVigenciaInicial);
		rv.setDtVigenciaFinal(dtVigenciaFinal);
		getRotaViagemService().validateVigenciaBeforeStore(rv);

		// se é inserção, retorna BusinessException que será um confirm na tela.
		if (bean.getLong("idRotaViagem") == null) {
			throw new BusinessException("LMS-29063");
		}

		return this.storeNaoAtribuiServicos(bean);
	}

	/**
	 * Salva Rota viagem e cria serviços da rota.
	 * @param bean
	 * @return
	 */
	public Map storeAtribuiServicos(TypedFlatMap bean) {
		// Carrega todos os serviços ativos.
		List servicos = this.servicoService.findIdsServicosAtivos();

		// Realiza salvar padrão da tela de 'Manter Rotas de Viagem'.
		TypedFlatMap rotaViagem = (TypedFlatMap)this.store(bean);

		// Percorre todos os serviços ativos e salva um serviço para rota de viagem com a mesma vigência.
		for (Iterator i = servicos.iterator() ; i.hasNext() ; )
			this.storeServicoRota(
					rotaViagem.getLong("idRotaViagem"),
					(Long)i.next(),	
					rotaViagem.getYearMonthDay("dtVigenciaInicial"),
					rotaViagem.getYearMonthDay("dtVigenciaFinal"));

		// retorna Map criado no método STORE para a tela, com valores setados no negócio:
		return rotaViagem;
	}

	/**
	 * Salva um serviço da Rota.
	 * 
	 * ATENÇÂO! ESTE MÉTODO DEVE SER UTILIZADO APENAS NA INSERÇÂO DE UMA ROTAVIAGEM!!!
	 * 
	 * @param idRotaViagem
	 * @param idServico
	 * @param dtVigenciaInicial
	 * @param dtVigenciaFinal
	 */
	private void storeServicoRota(Long idRotaViagem, Long idServico,
			YearMonthDay dtVigenciaInicial, YearMonthDay dtVigenciaFinal) {
		// Instância de 3 pojos:
		ServicoRotaViagem s = new ServicoRotaViagem();
		RotaViagem r = new RotaViagem();
		Servico srv = new Servico();
		// Setando o id de RotaViagem com o id salvo na inserção:
		r.setIdRotaViagem(idRotaViagem);
		// Como é uma inserção, garantimos que versão é 0!!!
		r.setVersao(Integer.valueOf(0));
		// Setando o id o Servico:
		srv.setIdServico(idServico);
		// Carregamos os atributos do POJO de ServicoRotaViagem:
		s.setRotaViagem(r);
		s.setServico(srv);
		s.setDtVigenciaInicial(dtVigenciaInicial);
		s.setDtVigenciaFinal(dtVigenciaFinal);
		// Salva pojo com método padrão da ServicoRotaViagemService.
		this.servicoRotaViagemService.store(s);
	}

	/**
	 * Store que não salva serviços.
	 * @param bean
	 * @return
	 */
	public Map storeNaoAtribuiServicos(TypedFlatMap bean) {
		return this.store(bean);
	}

	/**
	 * Store padrão que salva Rota Viagem e n RotasIdaVoltas.
	 * 
	 * @param bean
	 * @return Map com informações da 'Rota Viagem' e das 'Rotas de Ida e Volta'.
	 */
	public Map store(TypedFlatMap mapView) {
		// TypedFlatMap o qual retornará para camada View.
		TypedFlatMap retorno = new TypedFlatMap();

		MasterEntry entry = getMasterFromSession(mapView.getLong("idRotaViagem"), true);

		limparDadosTabVolta(mapView, entry);
		
		RotaViagem rv = (RotaViagem)entry.getMaster();
		rv.setDtVigenciaInicial(mapView.getYearMonthDay("dtVigenciaInicial"));
		rv.setDtVigenciaFinal(mapView.getYearMonthDay("dtVigenciaFinal"));

		Long idTipoMeioTransporte = mapView.getLong("tipoMeioTransporte.idTipoMeioTransporte");
		if (idTipoMeioTransporte != null) {
			TipoMeioTransporte tipoMeioTransporte = new TipoMeioTransporte();
			tipoMeioTransporte.setIdTipoMeioTransporte(idTipoMeioTransporte);
			rv.setTipoMeioTransporte(tipoMeioTransporte);	
		}

		Long idCliente = mapView.getLong("cliente.idCliente");
		if (idCliente != null) {
			Cliente cliente = new Cliente();
			cliente.setIdCliente(idCliente);
			rv.setCliente(cliente);
		}

		rv.setTpSistemaRota(mapView.getDomainValue("tpSistemaRota"));
		rv.setTpRota(mapView.getDomainValue("tpRota"));
		rv.setVersao(mapView.getInteger("versao"));

		rv.setRotaIdaVoltas(new ArrayList());

		ItemList itemsIda = getItemsFromSession(entry,"trechosIda");
		ItemList itemsVolta = getItemsFromSession(entry,"trechosVolta");

		ItemListConfig configIda = getMasterConfig().getItemListConfig("trechosIda");
		ItemListConfig configVolta = getMasterConfig().getItemListConfig("trechosVolta");
		
		// Salva a rota Ida e carrega no map 'retorno' dsRota que deve retornar para a tela.
		Long idRotaIda = null;
		if (mapView.get("rotaIda.tpRotaIdaVolta") != null) {
			if ( !((rv.getIdRotaViagem() != null && !itemsIda.isInitialized()) || itemsIda.hasItems()) )
				throw new BusinessException("LMS-29064");

			//atualizar vlFreteCarreteiro
			BigDecimal vlFreteCarreteiro = calculaValorFreteCarreteiro(rv.getIdRotaViagem(), itemsIda,configIda, "I", mapView.getLong("rotaIda.idRotaIdaVolta"));
			mapView.put("rotaIda.vlFreteCarreteiro", vlFreteCarreteiro);
			
			RotaIdaVolta rotaIdaVolta = this.storeRotaIdaVolta(mapView,rv,"rotaIda");
			idRotaIda = rotaIdaVolta.getIdRotaIdaVolta();
			rv.getRotaIdaVoltas().add(rotaIdaVolta);
			retorno.put("rotaIda.dsRota",getRotaViagemService().getRotaByFiliais(mapView.getList("rotaIda.filiaisRota")));
		}
		Long idRotaVolta = null;
		if (mapView.get("rotaVolta.tpRotaIdaVolta") != null) {
			if ( !((rv.getIdRotaViagem() != null && !itemsVolta.isInitialized()) || itemsVolta.hasItems()) )
				throw new BusinessException("LMS-29065");

			//atualizar vlFreteCarreteiro
			BigDecimal vlFreteCarreteiro = calculaValorFreteCarreteiro(rv.getIdRotaViagem(),itemsVolta,configVolta, "V", mapView.getLong("rotaVolta.idRotaIdaVolta"));
			mapView.put("rotaVolta.vlFreteCarreteiro", vlFreteCarreteiro);
			
			RotaIdaVolta rotaIdaVolta = this.storeRotaIdaVolta(mapView,rv,"rotaVolta");
			idRotaVolta = rotaIdaVolta.getIdRotaIdaVolta();
			rv.getRotaIdaVoltas().add(rotaIdaVolta);
			retorno.put("rotaVolta.dsRota",getRotaViagemService().getRotaByFiliais(mapView.getList("rotaVolta.filiaisRota")));
		}


		if (rv.getTpRota().getValue().equals("EX")) {
			this.validateTrechosHoraRequired(rv.getIdRotaViagem(),itemsIda,configIda, "I", idRotaIda);
			this.validateTrechosHoraRequired(rv.getIdRotaViagem(),itemsVolta,configVolta, "V", idRotaVolta);
			this.validateTrechosValorRateioRequired(rv.getIdRotaViagem(),itemsIda,configIda, "I", idRotaIda);
			this.validateTrechosValorRateioRequired(rv.getIdRotaViagem(),itemsVolta,configVolta, "V", idRotaVolta);
		}

		RotaViagem rotaViagem = (RotaViagem)getRotaViagemService().storeWithItems(rv, itemsIda, configIda, null, null, itemsVolta, configVolta);

		List<RotaIdaVolta> rotaIdaVoltas = rv.getRotaIdaVoltas();
		for(RotaIdaVolta rotaIdaVoltaAux : rotaIdaVoltas) {
			if (rotaIdaVoltaAux.getTpRotaIdaVolta().getValue().equals("I")) {
				retorno.put("rotaIda.idRotaIdaVolta",rotaIdaVoltaAux.getIdRotaIdaVolta());
				retorno.put("rotaIda.versao",rotaIdaVoltaAux.getVersao());
				retorno.put("rotaIda.nrRota",rotaIdaVoltaAux.getNrRota());
				retorno.put("rotaIda.vlFreteCarreteiro",rotaIdaVoltaAux.getVlFreteCarreteiro());
			} else if (rotaIdaVoltaAux.getTpRotaIdaVolta().getValue().equals("V")) {
				retorno.put("rotaVolta.idRotaIdaVolta",rotaIdaVoltaAux.getIdRotaIdaVolta());
				retorno.put("rotaVolta.versao",rotaIdaVoltaAux.getVersao());
				retorno.put("rotaVolta.nrRota",rotaIdaVoltaAux.getNrRota());
				retorno.put("rotaVolta.vlFreteCarreteiro",rotaIdaVoltaAux.getVlFreteCarreteiro());
			}
		}

		// Carrega dados básicos para retorno na aba detalhamento.
		retorno.put("idRotaViagem",rotaViagem.getIdRotaViagem());
		retorno.put("versao",rotaViagem.getVersao());
		// É necessário carregas as datas de vigência pois elas são usadas na inserção de serviços da rota.
		YearMonthDay dtVigenciaInicial = rotaViagem.getDtVigenciaInicial();
		retorno.put("dtVigenciaInicial",dtVigenciaInicial);
		YearMonthDay dtVigenciaFinal = rotaViagem.getDtVigenciaFinal();
		retorno.put("dtVigenciaFinal",dtVigenciaFinal);

		itemsIda.resetItemsState();
		itemsVolta.resetItemsState();
		updateMasterInSession(entry);

		// Antes de retornar um map, coloca no mesmo o número de ação vigência.
		retorno.put("acaoVigenciaAtual",JTVigenciaUtils.getIntegerAcaoVigencia(
				dtVigenciaInicial.plusDays(1),dtVigenciaFinal));

		return retorno;
	}
	
	private BigDecimal calculaValorFreteCarreteiro(Long masterId, ItemList items, ItemListConfig config, String tipoRota, Long idRotaIdaVolta){
		BigDecimal valorFrete = BigDecimal.ZERO;
		
		Map<String, Object> params = new TypedFlatMap();
		params.put("idRotaViagem", masterId);
		params.put("idRotaIdaVolta", idRotaIdaVolta);
		params.put("tipoRotaIdaVolta", tipoRota);
		for (Iterator i = items.iterator(masterId, params, config) ; i.hasNext() ; ) {
			TrechoRotaIdaVolta triv = (TrechoRotaIdaVolta)i.next();
			valorFrete = valorFrete.add(BigDecimalUtils.defaultBigDecimal(triv.getVlRateio()));
		}
		
		return valorFrete;
	}

	/**
	 * LMS-3494 - Erro ao fechar vigência de rotas de viagem.
	 * Somente os tipos "Bate e volta" e "Vai e vem" possuem "Rota de Volta". 
	 * 
	 * @param mapView
	 */
	private void limparDadosTabVolta(TypedFlatMap mapView, MasterEntry entry) {
		String tpSistemaRota = mapView.getString("tpSistemaRota");

		if (!"B".equals(tpSistemaRota) && !"V".equals(tpSistemaRota)) {
			ItemList itemListVolta = super.getItemsFromSession(entry, "trechosVolta");

			if (itemListVolta != null && !itemListVolta.isEmpty()) {
				for (int i = 0; i < itemListVolta.size(); i++) {
					itemListVolta.remove(i);
				}
			}
		}
	}
	
	/**
	 * Salva um registro de Rota!!! e APENAS cria e retorna um pojo de RotaIdaVolta
	 * NÃO SALVA UMA ROTA DE IDA E VOLTA.
	 * @param rotaIdaVolta
	 * @param rotaViagem
	 * @return
	 */
	private RotaIdaVolta storeRotaIdaVolta(TypedFlatMap mapView, RotaViagem rotaViagem, String itemAlias) {
		if (!itemAlias.endsWith(".")) {
			itemAlias = itemAlias.concat(".");
		}

		RotaIdaVolta riv = new RotaIdaVolta();
		riv.setIdRotaIdaVolta(mapView.getLong(itemAlias + "idRotaIdaVolta"));
		riv.setNrRota(mapView.getInteger(itemAlias + "nrRota"));
		riv.setNrDistancia(mapView.getInteger(itemAlias + "nrDistancia"));
		riv.setObItinerario(mapView.getString(itemAlias + "obItinerario"));
		riv.setObRotaIdaVolta(mapView.getString(itemAlias + "obRotaIdaVolta"));
		riv.setTpRotaIdaVolta(mapView.getDomainValue(itemAlias + "tpRotaIdaVolta"));
		riv.setVersao(mapView.getInteger(itemAlias + "versao"));
		riv.setVlFreteKm(mapView.getBigDecimal(itemAlias + "vlFreteKm"));
		riv.setVlPremio(mapView.getBigDecimal(itemAlias + "vlPremio"));
		riv.setVlFreteCarreteiro(mapView.getBigDecimal(itemAlias + "vlFreteCarreteiro"));

		MoedaPais mp = new MoedaPais();
		mp.setIdMoedaPais(mapView.getLong(itemAlias + "moedaPais.idMoedaPais"));
		riv.setMoedaPais(mp);

		Rota rota = this.rotaService.storeValidaByFiliais(getListOfFiliais(mapView.getList(itemAlias + "filiaisRota")));

		riv.setRota(rota);
		riv.setRotaViagem(rotaViagem);

		return riv;		
	}

	/**
	 * Cria uma lista de <b>Filial</b>
	 * @param lMap
	 * @return
	 */
	private List getListOfFiliais(List lMap) {
		List l = new ArrayList();
		TypedFlatMap m = new TypedFlatMap();
		for (Iterator i = lMap.iterator() ; i.hasNext() ; ) {
			Filial filial = new Filial();
			m = (TypedFlatMap)i.next();
			filial.setIdFilial(m.getLong("filial.idFilial"));
			filial.setSgFilial(m.getString("filial.sgFilial"));
			l.add(filial);
		}
		return l;			
	}

	public void removeById(Long id) {
		getRotaViagemService().removeByIdComplete((Long)id);
		newMaster();
	}

	/**
	 *
	 */
	@ParametrizedAttribute(type = java.lang.Long.class)
	public void removeByIds(List ids) {
		getRotaViagemService().removeByIdsComplete(ids);
	}

	public TypedFlatMap findDistanciaByFiliais(TypedFlatMap criteria) {
		TypedFlatMap retorno = new TypedFlatMap();

		Long idFilialOrigem = criteria.getLong("idFilialOrigem");
		Long idFilialDestino = criteria.getLong("idFilialDestino");
		FluxoFilial fluxoFilial = fluxoFilialService.findFluxoFilial(idFilialOrigem, idFilialDestino, JTDateTimeUtils.getDataAtual(), null);
		if(fluxoFilial != null) {
			Integer nrDistancia = fluxoFilial.getNrDistancia();
			if(fluxoFilial.getNrGrauDificuldade() != null) {
				nrDistancia = IntegerUtils.add(nrDistancia, fluxoFilial.getNrGrauDificuldade());
			}
			retorno.put("nrDistancia", nrDistancia);
		}
		return retorno;
	}

	/**
	 * Consulta distância e itinerário através do Id de uma Rota Viagem
	 * @param criteria
	 * @return Map com nrDistância, obItinerario e dsRota.
	 */
	public Map findDistanciaByRota(TypedFlatMap criteria) {
		Object idRotaViagem = criteria.get("idRotaViagem");
		Object dsRota = criteria.get("filiaisRota");

		Map info = null;

		Long idRota = null;
		if (dsRota != null && !((String)dsRota).equals("")) {
			idRota = this.rotaService.findIdRotaByDescricao((String)dsRota);
		}

		if (idRota != null) {
			info = getRotaViagemService().findInfoByRotaViagem(
					(idRotaViagem != null && !((String)idRotaViagem).equals("")) ? Long.valueOf((String)idRotaViagem) : Long.valueOf(0),
					idRota);
		}

		Object nrDistancia = null;
		if (info != null) {
			nrDistancia = info.get("nrDistancia");
		}

		if(nrDistancia == null) {
			List filiais = getListOfFiliais(criteria.getList("listFiliaisRota"));
			nrDistancia = fluxoFilialService.findDistanciaTotalFluxoFilialOrigemDestino(filiais,JTDateTimeUtils.getDataAtual());
			if (info == null && nrDistancia != null) {
				info = new HashMap();
				info.put("nrDistancia",nrDistancia);
			}				
		}

		return info;
	}

	/**
	 * Cria uma nova rota a partir da rota recebida por parâmetro e
	 * finaliza a vigência da rota recebida.
	 * @param map com <b>idRotaViagem</b> e <b>dtVigenciaInicial</b>
	 * @return
	 */
	public Map storeAlterarRota(TypedFlatMap map) {
		Long idRotaViagem = map.getLong("idRotaViagem");
		YearMonthDay dtVigenciaInicial = map.getYearMonthDay("dtVigenciaInicial");
		Long newId = getRotaViagemService().storeAlterarRota(idRotaViagem,dtVigenciaInicial);
		
		return this.findByIdRotaViagem(newId);
	}
	
	public Map validaValorMaximoRateio(TypedFlatMap criteria) {
		
		ParametroGeral parametroGeral = parametroGeralService.findByNomeParametro("VALOR_MAX_VR", false);
		BigDecimal valorMaximoRateio = new BigDecimal(parametroGeral.getDsConteudo());
		BigDecimal vlRateio = criteria.getBigDecimal("vlRateio");
		
		Map map = new HashMap();
		map.put("blValorRateioValido", vlRateio.compareTo(valorMaximoRateio) <= 0);
		map.put("valorMaxVr", valorMaximoRateio);
		
		return map;
	}
	
	/**
	 * retorna vlFreteKm a partir de um <b>Map</b> com <b>nrDistancia</b> e <b>vlFreteCarreteiro</b>.
	 * @param criteria
	 * @return
	 */
	public Map getFreteKm(TypedFlatMap criteria) {
		Map map = new HashMap();
		Integer nrDistancia = criteria.getInteger("nrDistancia");
		BigDecimal vlFreteCarreteiro = criteria.getBigDecimal("vlFreteCarreteiro");
		if (nrDistancia != null && vlFreteCarreteiro != null)
			map.put("vlFreteKm",FormatUtils.formatDecimal("#,##0.00",
						calculateFreteKm(nrDistancia,vlFreteCarreteiro),
						true));
		return map;
	}
	
	/**
	 * Calcula o o valor do FreteKm a partir de nrDistancia e vlFreteCarreteiro.
	 * @param nrDistancia
	 * @param vlFreteCarreteiro
	 * @return
	 */
	public BigDecimal calculateFreteKm(Integer nrDistancia, BigDecimal vlFreteCarreterio) {
		if (nrDistancia != null && nrDistancia.compareTo(IntegerUtils.ZERO) != 0 &&
				vlFreteCarreterio != null && !CompareUtils.eq(vlFreteCarreterio, BigDecimalUtils.ZERO))
			return new BigDecimal(vlFreteCarreterio.doubleValue() / nrDistancia.doubleValue());

		return new BigDecimal(0);
	}
	
	public Map calculaTotalRateioIda(TypedFlatMap parameters) {
		return calculaTotalRateio(parameters, "trechosIda");
	}

	public Map calculaTotalRateioVolta(TypedFlatMap parameters) {
		return calculaTotalRateio(parameters, "trechosVolta");
	}
	
	public Map calculaTotalRateio(TypedFlatMap parameters, String itemAlias) {
		Long masterId = parameters.getLong("masterId");
		MasterEntry entry = getMasterFromSession(masterId,false);
		ItemList items = getItemsFromSession(entry,itemAlias);

		BigDecimal vlTotalRateio = null;
		
		ItemListConfig config = getMasterConfig().getItemListConfig(itemAlias);
		for (Iterator<TrechoRotaIdaVolta> i = items.iterator(masterId, config) ; i.hasNext() ; ) {
			if(vlTotalRateio == null){
				vlTotalRateio = BigDecimal.ZERO;
			}
			TrechoRotaIdaVolta triv = i.next();
			vlTotalRateio = vlTotalRateio.add(BigDecimalUtils.defaultBigDecimal(triv.getVlRateio()));
		}
		
		Map map = new HashMap();
		map.put("vlTotalRateio", vlTotalRateio != null ? FormatUtils.formatDecimal("#,##0.00",vlTotalRateio) : null);
		
		return map;
	}

	/**
	 * Ao remover alguma filial do lists de rotaIdaVolta, deve-se validar se a filial já está sendo utilizada.
	 * @param map
	 */
	public void validateExistenciaTrechos(TypedFlatMap map) {
		Long idFilial = map.getLong("idFilial");
		Long idRotaViagem = map.getLong("idRotaViagem");

		MasterEntry entry = getMasterFromSession(idRotaViagem,false);
		ItemList items = null;
		ItemListConfig itemsConfig = null;
		switch (map.getString("tpRota").charAt(0)) {
		case 'I':
			items = getItemsFromSession(entry,"trechosIda");
			itemsConfig = getMasterConfig().getItemListConfig("trechosIda");
			break;
		case 'V':
			items = getItemsFromSession(entry,"trechosVolta");		
			itemsConfig = getMasterConfig().getItemListConfig("trechosVolta");
			break;
		default:
			break;
		}

		Byte nrOrdem = map.getByte("nrOrdem");
		if (getRotaViagemService().verificaTrechosInSession(idRotaViagem, map,
				items, itemsConfig, idFilial, nrOrdem)) {
			throw new BusinessException("LMS-29062");
		}
	}

	/**
	 * Retorna valores da combo de moeda a partir do país do usuário logado.
	 * @return
	 */
	public List findMoedaByPais() {
		Pais p = SessionUtils.getPaisSessao();
		return configuracoesFacade.getMoedasPais(p.getIdPais(), Boolean.TRUE);
	}

	/**
	 * Retorna lista com tipos de meio de transporte para a combo de meio de transporte.
	 * @param criteria
	 * @return
	 */
	public List<TypedFlatMap> findTipoMeioTransporte(Map<String, Object> criteria) {
		List<TipoMeioTransporte> tiposMeioTransporte = tipoMeioTransporteService.findTiposSemComposicao(criteria);
		List<TypedFlatMap> retorno = new ArrayList<TypedFlatMap>(tiposMeioTransporte.size());

		for(TipoMeioTransporte tipoMeioTransporte : tiposMeioTransporte) {
			TypedFlatMap r = new TypedFlatMap();
			r.put("idTipoMeioTransporte", tipoMeioTransporte.getIdTipoMeioTransporte());
			r.put("dsTipoMeioTransporte", tipoMeioTransporte.getDsTipoMeioTransporte());
			retorno.add(r);
		}

		return retorno;
	}

	/**
	 * Retorna moeda do pais mais utilizada.
	 * @return Map com o idMoedaPais
	 */
	public Map<String, Object> findMoedaPadrao() {
		MoedaPais mp = getRotaViagemService().findMoedaPaisPadrao();
		Map<String, Object> m = new HashMap<String, Object>();
		m.put("idMoedaPais", mp.getIdMoedaPais());
		return m;
	}

	/**
	 * Retorna valor do pedágio de acordo com idMoedaPais, idRotaIdaVolta e idTipoMeioTransporte.
	 * @author Felipe Ferreira
	 * @param criteria
	 * @return
	 */
	public Map<String, Object> findValorPedagio(TypedFlatMap criteria) {
		Map<String, Object> result = new HashMap<String, Object>();

		List<Filial> filiais = getListOfFiliais(criteria.getList("listFiliaisRota"));
		if (filiais.size() < 2)
			return result;

		Long idTipoMeioTransporte = criteria.getLong("idTipoMeioTransporte");
		Long idMoedaPais = criteria.getLong("idMoedaPais");
		BigDecimal valor = getRotaViagemService().findVlPedagio(idMoedaPais, idTipoMeioTransporte, filiais);

		result.put("vlPedagio", FormatUtils.formatDecimal("#,##0.00",valor));
		return result;
	}

//####################################
// Métodos específicos das abas. DF2!
//####################################

	public ResultSetPage findPaginatedTrechoRotaIda(Map parameters) {
		return findPaginatedTrechoRotaIdaVolta(parameters, "trechosIda");
	}
	
	public ResultSetPage findPaginatedTrechoRotaVolta(Map parameters) {
		return findPaginatedTrechoRotaIdaVolta(parameters, "trechosVolta");
	}

	public ResultSetPage findPaginatedTrechoRotaIdaVolta(Map parameters,String itemAlias) {
		if (parameters.get("idRotaIdaVolta") == null)
			parameters.put("idRotaIdaVolta","");
		ResultSetPage rsp = findPaginatedItemList(parameters, itemAlias);

		FilterResultSetPage frsp = new FilterResultSetPage(rsp) {

			public Map filterItem(Object item) {
				TrechoRotaIdaVolta triv = (TrechoRotaIdaVolta)item;				
				TypedFlatMap row = new TypedFlatMap();
				row.put("idTrechoRotaIdaVolta",triv.getIdTrechoRotaIdaVolta());
				row.put("filialRotaByIdFilialRotaOrigem.filial.sgFilial", triv.getFilialRotaByIdFilialRotaOrigem().getFilial().getSgFilial());
				row.put("filialRotaByIdFilialRotaOrigem.filial.pessoa.nmFantasia", triv.getFilialRotaByIdFilialRotaOrigem().getFilial().getPessoa().getNmFantasia());
				row.put("filialRotaByIdFilialRotaDestino.filial.sgFilial", triv.getFilialRotaByIdFilialRotaDestino().getFilial().getSgFilial());
				row.put("filialRotaByIdFilialRotaDestino.filial.pessoa.nmFantasia", triv.getFilialRotaByIdFilialRotaDestino().getFilial().getPessoa().getNmFantasia());
				row.put("hrSaida", triv.getHrSaida());
				row.put("nrDistancia", triv.getNrDistancia());
				row.put("nrTempoViagem" , JTFormatUtils.formatTime((triv.getNrTempoViagem().longValue() * 60), 2, 1));
				row.put("nrTempoOperacao" , JTFormatUtils.formatTime((triv.getNrTempoOperacao().longValue() * 60), 2, 1));
				row.put("blDomingo", triv.getBlDomingo());
				row.put("blSegunda", triv.getBlSegunda());
				row.put("blTerca", triv.getBlTerca());
				row.put("blQuarta", triv.getBlQuarta());
				row.put("blQuinta", triv.getBlQuinta());
				row.put("blSexta", triv.getBlSexta());
				row.put("blSabado", triv.getBlSabado());		
				row.put("vlRateio", triv.getVlRateio());		
				return row;
			}

		};

		return (ResultSetPage)frsp.doFilter();
	}

	public Integer getRowCountTrechoRotaIda(Map parameters) {
		return getRowCountTrechoRotaIdaVolta(parameters, "trechosIda");
	}

	public Integer getRowCountTrechoRotaVolta(Map parameters) {
		return getRowCountTrechoRotaIdaVolta(parameters, "trechosVolta");
	}

	public Integer getRowCountTrechoRotaIdaVolta(Map parameters,String itemAlias){
		if (parameters.get("idRotaIdaVolta") == null)
			parameters.put("idRotaIdaVolta","");
		return getRowCountItemList(parameters, itemAlias);
	}

	public Object findByIdTrechoRotaIda(MasterDetailKey key) {
		return findByIdTrechoRotaIdaVolta(key, "trechosIda");
	}

	public Object findByIdTrechoRotaVolta(MasterDetailKey key) {
		return findByIdTrechoRotaIdaVolta(key, "trechosVolta");
	}

	public TypedFlatMap findByIdTrechoRotaIdaVolta(MasterDetailKey key, String itemAlias) {
		TrechoRotaIdaVolta triv = (TrechoRotaIdaVolta)findItemById(key, itemAlias);
		TypedFlatMap retorno = new TypedFlatMap();

		retorno.put("idTrechoRotaIdaVolta",triv.getIdTrechoRotaIdaVolta());
		retorno.put("filialRotaByIdFilialRotaOrigem.filial.idFilial", triv.getFilialRotaByIdFilialRotaOrigem().getFilial().getIdFilial());
		retorno.put("filialRotaByIdFilialRotaOrigem.filial.sgFilial", triv.getFilialRotaByIdFilialRotaOrigem().getFilial().getSgFilial());
		retorno.put("filialRotaByIdFilialRotaOrigem.filial.pessoa.nmFantasia", triv.getFilialRotaByIdFilialRotaOrigem().getFilial().getPessoa().getNmFantasia());
		retorno.put("filialRotaByIdFilialRotaOrigem.nrOrdem", triv.getFilialRotaByIdFilialRotaOrigem().getNrOrdem());

		retorno.put("filialRotaByIdFilialRotaDestino.filial.idFilial", triv.getFilialRotaByIdFilialRotaDestino().getFilial().getIdFilial());
		retorno.put("filialRotaByIdFilialRotaDestino.filial.sgFilial", triv.getFilialRotaByIdFilialRotaDestino().getFilial().getSgFilial());
		retorno.put("filialRotaByIdFilialRotaDestino.filial.pessoa.nmFantasia", triv.getFilialRotaByIdFilialRotaDestino().getFilial().getPessoa().getNmFantasia());
		retorno.put("filialRotaByIdFilialRotaDestino.nrOrdem", triv.getFilialRotaByIdFilialRotaDestino().getNrOrdem());

		retorno.put("hrSaida", triv.getHrSaida());
		retorno.put("nrDistancia", triv.getNrDistancia());
		retorno.put("nrTempoViagem",
				FormatUtils.converteMinutosParaHorasMinutos(Long.valueOf(triv.getNrTempoViagem().longValue()),FormatUtils.ESCALA_HHH));
		retorno.put("nrTempoOperacao",
				FormatUtils.converteMinutosParaHorasMinutos(Long.valueOf(triv.getNrTempoOperacao().longValue()),FormatUtils.ESCALA_HHH));
		retorno.put("versao", triv.getVersao());
		retorno.put("blDomingo", triv.getBlDomingo());
		retorno.put("blSegunda", triv.getBlSegunda());
		retorno.put("blTerca", triv.getBlTerca());
		retorno.put("blQuarta", triv.getBlQuarta());
		retorno.put("blQuinta", triv.getBlQuinta());
		retorno.put("blSexta", triv.getBlSexta());
		retorno.put("blSabado", triv.getBlSabado());
		
		retorno.put("vlRateio", triv.getVlRateio());		

		return retorno;
	}

	/**
	 *
	 */
	@ParametrizedAttribute(type = java.lang.Long.class)
	public void removeByIdsTrechoRotaIda(List<Long> ids) {
		removeByIdsTrechoRotaIdaVolta(ids, "trechosIda");
	}

	/**
	 */
	@ParametrizedAttribute(type = java.lang.Long.class)
	public void removeByIdsTrechoRotaVolta(List<Long> ids) {
		removeByIdsTrechoRotaIdaVolta(ids, "trechosVolta");
	}

	public void removeByIdsTrechoRotaIdaVolta(List<Long> ids, String itemAlias) {
		for(Long idTrechoRotaIdaVolta : ids) {
			Integer nbrPontosParada = pontoParadaTrechoService.getRowCountByTrechoRotaIdaVolta(idTrechoRotaIdaVolta);
			if(CompareUtils.gt(nbrPontosParada, IntegerUtils.ZERO)) {
				throw new BusinessException("childRecordFoundViolated");
			}
		}
		super.removeItemByIds(ids, itemAlias);
	}

// Métodos responsáveis pelas validações antes de salvar a instância de um trecho de rota ida Volta.
//###################################################################################################	

	public Serializable saveTrechoRotaIda(TypedFlatMap parameters) {
		return saveTrechoRotaIdaVolta(parameters, "trechosIda");
	}

	public Serializable saveTrechoRotaVolta(TypedFlatMap parameters) {
		return saveTrechoRotaIdaVolta(parameters, "trechosVolta");
	}

	/**
	 * Salva um item Descrição Padrão na sessão.
	 * 
	 * @param bean
	 * @return
	 */
	public Serializable saveTrechoRotaIdaVolta(TypedFlatMap parameters, String itemAlias) {
		Long idFilialOrigem = parameters.getLong("filialRotaByIdFilialRotaOrigem.filial.idFilial");
		Long idFilialDestino = parameters.getLong("filialRotaByIdFilialRotaDestino.filial.idFilial");
		if (idFilialOrigem.compareTo(idFilialDestino) == 0)
			throw new BusinessException("LMS-29055");

		Long nrOrdemOrigem = parameters.getLong("filialRotaByIdFilialRotaOrigem.nrOrdem");
		Long nrOrdemDestino = parameters.getLong("filialRotaByIdFilialRotaDestino.nrOrdem");
		if (nrOrdemOrigem.compareTo(nrOrdemDestino) > 0)
			throw new BusinessException("LMS-29156");

		if (!itemAlias.equals("trechosEvent")) {
			// Validamos se a distância do trecho não é maior que o da rota inteira:
			Long nrDistanciaRota = parameters.getLong("rotaIdaVolta.nrDistancia");
			if (nrDistanciaRota == null)
				nrDistanciaRota = LongUtils.ZERO;
			Long nrDistancia = parameters.getLong("nrDistancia");
			if (nrDistancia.compareTo(nrDistanciaRota) > 0)
				throw new BusinessException("LMS-29058");

			// Validamos se pelo menos um dia foi checado:
			if (!this.verificaPeloMenosUmDiaChecado(parameters))
				throw new BusinessException("LMS-26051");

			// Validamos se todos os trechos com mesma origem possuem mesmo horário de saída:
			Long masterId = parameters.getLong("masterId");
			Long idTrechoRotaIdaVolta = parameters.getLong("idTrechoRotaIdaVolta");
			Long idRotaIdaVolta = parameters.getLong("idRotaIdaVolta");
			TimeOfDay hrSaida = parameters.getTimeOfDay("hrSaida");
			this.validateTrechosHoraInformada(masterId, idRotaIdaVolta, idTrechoRotaIdaVolta,
					idFilialOrigem, idFilialDestino, hrSaida, itemAlias);	
		}
		return saveTrechoAfterValidation(parameters, itemAlias);
	}

	/**
	 * Valida-se se todos os trechos com mesma filial de origem possuem mesmo horário de saída.
	 * 
	 * @param idRotaViagem
	 * @param idRotaIdaVolta
	 * @param idTrechoRotaIdaVolta
	 * @param idFilialOrigem
	 * @param hrSaida
	 * @param itemAlias
	 * @return
	 */
	private boolean validateTrechosHoraInformada(Long idRotaViagem, Long idRotaIdaVolta, Long idTrechoRotaIdaVolta,
			Long idFilialOrigem, Long idFilialDestino, TimeOfDay hrSaida, String itemAlias) {

		MasterEntry entry = getMasterFromSession(idRotaViagem,false);
		ItemList items = getItemsFromSession(entry,itemAlias);
		ItemListConfig itemsConfig = getMasterConfig().getItemListConfig(itemAlias);

		boolean existeOutroTrecho = false;

		if (idRotaIdaVolta != null)
			existeOutroTrecho = this.trechoRotaIdaVoltaService.findTrechosComHoraInformada(
					idTrechoRotaIdaVolta, idRotaIdaVolta, idFilialOrigem, hrSaida).size() > 0;

		if (this.validateExistenciaTrechosRepetidos(idRotaViagem,idTrechoRotaIdaVolta,idFilialOrigem,idFilialDestino,itemAlias))
			throw new BusinessException("LMS-29140");

		if (!existeOutroTrecho && items.isInitialized())
			 existeOutroTrecho = getRotaViagemService().verificaTrechosHoraInformada(idRotaViagem,
					 items,itemsConfig, idTrechoRotaIdaVolta,idFilialOrigem,hrSaida);

		if (existeOutroTrecho)
			throw new BusinessException("LMS-29061");

		return true;
	}

	/**
	 * Valida se todos os items possuem hora informada
	 * 
	 * @param masterId
	 * @param items
	 * @param config
	 */
	private void validateTrechosHoraRequired(Long masterId, ItemList items, ItemListConfig config, String tipoRota, Long idRotaIdaVolta) {
		Map<String, Object> params = new TypedFlatMap();
		params.put("idRotaViagem", masterId);
		params.put("idRotaIdaVolta", idRotaIdaVolta);
		params.put("tipoRotaIdaVolta", tipoRota);
		for (Iterator i = items.iterator(masterId, params, config) ; i.hasNext() ; ) {
			TrechoRotaIdaVolta triv = (TrechoRotaIdaVolta)i.next();
			if (triv.getHrSaida() == null)
				throw new BusinessException("LMS-29124");
		}
	}
	
	/**
	 * Valida se todos os items possuem hora informada
	 * 
	 * @param masterId
	 * @param items
	 * @param config
	 */
	private void validateTrechosValorRateioRequired(Long masterId, ItemList items, ItemListConfig config, String tipoRota, Long idRotaIdaVolta) {
		Map<String, Object> params = new TypedFlatMap();
		params.put("idRotaViagem", masterId);
		params.put("idRotaIdaVolta", idRotaIdaVolta);
		params.put("tipoRotaIdaVolta", tipoRota);
		for (Iterator i = items.iterator(masterId, params, config) ; i.hasNext() ; ) {
			TrechoRotaIdaVolta triv = (TrechoRotaIdaVolta)i.next();
			if (triv.getVlRateio() == null)
				throw new BusinessException("LMS-29194");
		}
	}

	public Serializable saveTrechoAfterValidationConfirmedIda(TypedFlatMap parameters) {
		return saveTrechoAfterValidationConfirmed(parameters, "trechosIda");
	}

	public Serializable saveTrechoAfterValidationConfirmedVolta(TypedFlatMap parameters) {
		return saveTrechoAfterValidationConfirmed(parameters, "trechosVolta");
	}

	/**
	 * Altera horário de saída de todos os trechos que estão na sessão que possuem a mesma filial
	 * de origem da instância que está sendo salva.
	 * 
	 * <b>Chamado após confirmação ao salvar na tela.</b>
	 * 
	 * @param parameters
	 * @param itemAlias
	 * @return
	 */
	public Serializable saveTrechoAfterValidationConfirmed(TypedFlatMap parameters, String itemAlias) {
		Long masterId = parameters.getLong("masterId");

		MasterEntry entry = getMasterFromSession(masterId,false);
		ItemList items = getItemsFromSession(entry,itemAlias);

		Long idFilialOrigem = parameters.getLong("filialRotaByIdFilialRotaOrigem.filial.idFilial");
		Long idFilialDestino = parameters.getLong("filialRotaByIdFilialRotaDestino.filial.idFilial");
		TimeOfDay hrSaida = parameters.getTimeOfDay("hrSaida");

		ItemListConfig config = getMasterConfig().getItemListConfig(itemAlias);
		for (Iterator<TrechoRotaIdaVolta> i = items.iterator(masterId, config) ; i.hasNext() ; ) {
			TrechoRotaIdaVolta triv = i.next();
			Filial filialOrigem = triv.getFilialRotaByIdFilialRotaOrigem().getFilial();
			Filial filialDestino = triv.getFilialRotaByIdFilialRotaDestino().getFilial();
			if(CompareUtils.eq(filialOrigem.getIdFilial(), idFilialOrigem)) {
				// Se registro que está sendo incluído possui mesmas filial de origem e destino,
				// o mesmo irá substituir o que já está cadastrado.
				if (filialDestino.getIdFilial().equals(idFilialDestino)) {
					parameters.put("idTrechoRotaIdaVolta",triv.getIdTrechoRotaIdaVolta());
					triv.setHrSaida(hrSaida);
				}
				// Atualiza a hora de saída de todos os trechos que possuem mesma filial de origem. 
				else if (CompareUtils.neNull(triv.getHrSaida(), hrSaida)) {
					triv.setHrSaida(hrSaida);
					saveItemInstanceOnSession(masterId,triv,itemAlias);
				}
			}
		}
		return saveTrechoAfterValidation(parameters, itemAlias);
	}

	public Serializable saveTrechoAfterValidationRefusedIda(TypedFlatMap parameters) {
		return saveTrechoAfterValidationRefused(parameters, "trechosIda");
	}

	public Serializable saveTrechoAfterValidationRefusedVolta(TypedFlatMap parameters) {
		return saveTrechoAfterValidationRefused(parameters, "trechosVolta");
	}

	/**
	 * Verifica se nenhum dos trechos que estão na memória possui a mesma filial de origem da instância a ser salva.
	 * Se existir, seta o horário de saída do trecho encontrado na instância a ser salva.
	 * 
	 * <b>Chamado após confirmação ao salvar na tela.</b>
	 * 
	 * @param parameters
	 * @param itemAlias
	 * @return
	 */
	public Serializable saveTrechoAfterValidationRefused(TypedFlatMap parameters, String itemAlias) {
		Long masterId = parameters.getLong("masterId");
		Long idTrechoRotaIdaVolta = parameters.getLong("idTrechoRotaIdaVolta");

		MasterEntry entry = getMasterFromSession(masterId,false);
		ItemList items = getItemsFromSession(entry,itemAlias);
		ItemListConfig config = getMasterConfig().getItemListConfig(itemAlias);

		Long idFilialOrigem = parameters.getLong("filialRotaByIdFilialRotaOrigem.filial.idFilial");
		Long idFilialDestino = parameters.getLong("filialRotaByIdFilialRotaDestino.filial.idFilial");
		TimeOfDay hrSaida = parameters.getTimeOfDay("hrSaida");

		Long origemSelecionado = parameters.getLong("origemSelecionado");
		Long destinoSelecionado = parameters.getLong("destinoSelecionado");
		if (origemSelecionado.compareTo(destinoSelecionado) > 0)
			throw new BusinessException("LMS-29056");

		// Não permite a inclusão de dois trechos com mesmas filiais de origem e destino.
		if (this.validateExistenciaTrechosRepetidos(masterId,idTrechoRotaIdaVolta,idFilialOrigem,idFilialDestino,itemAlias))
			throw new BusinessException("LMS-29140");

		for (Iterator<TrechoRotaIdaVolta> i = items.iterator(masterId, config) ; i.hasNext() ; ) {
			TrechoRotaIdaVolta triv = i.next();
			if(CompareUtils.eq(triv.getFilialRotaByIdFilialRotaOrigem().getFilial().getIdFilial(), idFilialOrigem)
					&& CompareUtils.neNull(triv.getHrSaida(), hrSaida)
			) {
				hrSaida = triv.getHrSaida();
				break;
			}
		}
		parameters.put("hrSaida", hrSaida);
		return saveTrechoAfterValidation(parameters, itemAlias);
	}

	public Serializable saveTrechoAfterValidationIda(TypedFlatMap parameters) {
		return saveTrechoAfterValidation(parameters, "trechosIda");
	}

	public Serializable saveTrechoAfterValidationVolta(TypedFlatMap parameters) {
		return saveTrechoAfterValidation(parameters, "trechosVolta");
	}

	public Serializable saveTrechoAfterValidation(TypedFlatMap parameters, String itemAlias) {
		return saveItemInstance(parameters, itemAlias);
	}

	private boolean validateExistenciaTrechosRepetidos(Long masterId,
			Long idTrechoRotaIdaVolta, Long idFilialOrigem, Long idFilialDestino, String itemAlias) {
		MasterEntry entry = getMasterFromSession(masterId,false);
		ItemList items = getItemsFromSession(entry,itemAlias);
		ItemListConfig config = getMasterConfig().getItemListConfig(itemAlias);

		boolean blExists = false;
		// Não permite a inclusão de dois trechos com mesmas filiais de origem e destino.
		for (Iterator i = items.iterator(masterId, config) ; i.hasNext() ; ) {
			TrechoRotaIdaVolta triv = (TrechoRotaIdaVolta)i.next();
			if (!triv.getIdTrechoRotaIdaVolta().equals(idTrechoRotaIdaVolta)) {
				Filial filialOrigem = triv.getFilialRotaByIdFilialRotaOrigem().getFilial();
				Filial filialDestino = triv.getFilialRotaByIdFilialRotaDestino().getFilial();
				if (filialOrigem.getIdFilial().equals(idFilialOrigem) &&
						filialDestino.getIdFilial().equals(idFilialDestino)) {
					blExists = true;
					break;
				}
			}
		}
		return blExists;
	}

//####################################

	public void newMaster() {
		super.newMaster();
	}

	protected MasterEntryConfig createMasterConfig(MasterDetailFactory masterFactory) {
		MasterEntryConfig config = masterFactory.createMasterEntryConfig(RotaViagem.class);

		// Comparador para realizar a ordenação dos items filhos de acordo com a regra de negócio.
		Comparator descComparator = new Comparator() {
			public int compare(Object o1, Object o2) {
				Collator collator = Collator.getInstance(LocaleContextHolder.getLocale());

				if ((o1 instanceof Comparable) && (o2 instanceof Comparable)) {
					return ((Comparable)o1).compareTo(o2);
				} else {
					String strComp1 = null;
					String strComp2 = null;

					strComp1 = ((TrechoRotaIdaVolta)o1).getFilialRotaByIdFilialRotaOrigem().getNrOrdem().toString() +
							((TrechoRotaIdaVolta)o1).getFilialRotaByIdFilialRotaDestino().getNrOrdem().toString();

					strComp2 = ((TrechoRotaIdaVolta)o2).getFilialRotaByIdFilialRotaOrigem().getNrOrdem().toString() +
							((TrechoRotaIdaVolta)o2).getFilialRotaByIdFilialRotaDestino().getNrOrdem().toString();

					if (strComp1 == null || strComp2 == null)
						return 0;
					return collator.compare(strComp1,strComp2);
				}
			}
		};

		ItemListConfig itemInit = new ItemListConfig() {
			private static final long serialVersionUID = 6592117110208997586L;

			public void setMasterOnItem(Object master, Object itemBean) {
				// avô:
				RotaViagem rv = (RotaViagem)master;
				// filho:
				RotaIdaVolta riv = new RotaIdaVolta();
				// neto:
				TrechoRotaIdaVolta triv = (TrechoRotaIdaVolta)itemBean;

				riv.setRotaViagem(rv);
				triv.setRotaIdaVolta(riv);
			}

			public List initialize(Long masterId, Map parameters) {
				Long idRotaIdaVolta = MapUtils.getLong(parameters, "idRotaIdaVolta");
				if (idRotaIdaVolta != null) {
					return trechoRotaIdaVoltaService.findTrechosByIdRotaIdaVolta(idRotaIdaVolta);
				} else
					return new ArrayList<TrechoRotaIdaVolta>(0);
			}

			public Integer getRowCount(Long masterId, Map parameters) {
				Object idRotaIdaVolta = parameters.get("idRotaIdaVolta");
				if (idRotaIdaVolta != null && !"".equals((String)idRotaIdaVolta)) {
					masterId = Long.valueOf((String)idRotaIdaVolta);
					return trechoRotaIdaVoltaService.getRowCountByRotaIdaVolta(Long.valueOf((String)idRotaIdaVolta));
				} else
					return Integer.valueOf(0);
			}

			public void modifyItemValues(Object newValues, Object bean) {
				Set ignore = new HashSet();
				ignore.add("versao");
				ReflectionUtils.syncObjectProperties(bean, newValues);
			}

			public Map configItemDomainProperties() {
				return null;
			}

			public Object populateNewItemInstance(Map params, Object bean) {
				TrechoRotaIdaVolta triv = new TrechoRotaIdaVolta();
				FilialRota fro = new FilialRota();
				FilialRota frd = new FilialRota();
				Filial fo = new Filial();
				Filial fd = new Filial();
				Pessoa po = new Pessoa();
				Pessoa pd = new Pessoa();

				fo.setPessoa(po);
				fd.setPessoa(pd);
				fro.setFilial(fo);
				frd.setFilial(fd);
				triv.setFilialRotaByIdFilialRotaOrigem(fro);
				triv.setFilialRotaByIdFilialRotaDestino(frd);

				TypedFlatMap parameters = (TypedFlatMap)params;

				triv.setIdTrechoRotaIdaVolta(parameters.getLong("idTrechoRotaIdaVolta"));
				triv.setNrDistancia(parameters.getInteger("nrDistancia"));
				triv.setHrSaida(parameters.getTimeOfDay("hrSaida"));

				Long nrTempoOperacao = FormatUtils.converteHorasMinutosParaMinutos(parameters.getString("nrTempoOperacao"),
						FormatUtils.ESCALA_HHH);
				triv.setNrTempoOperacao(Integer.valueOf(nrTempoOperacao.intValue()));				

				Long nrTempoViagem = FormatUtils.converteHorasMinutosParaMinutos(parameters.getString("nrTempoViagem"),
							FormatUtils.ESCALA_HHH);
				triv.setNrTempoViagem(Integer.valueOf(nrTempoViagem.intValue()));

				triv.setBlDomingo(parameters.getBoolean("blDomingo"));
				triv.setBlSegunda(parameters.getBoolean("blSegunda"));
				triv.setBlTerca(parameters.getBoolean("blTerca"));
				triv.setBlQuarta(parameters.getBoolean("blQuarta"));
				triv.setBlQuinta(parameters.getBoolean("blQuinta"));
				triv.setBlSexta(parameters.getBoolean("blSexta"));
				triv.setBlSabado(parameters.getBoolean("blSabado"));
				
				triv.setVlRateio(parameters.getBigDecimal("vlRateio"));

				fo.setIdFilial(parameters.getLong("filialRotaByIdFilialRotaOrigem.filial.idFilial"));
				fd.setIdFilial(parameters.getLong("filialRotaByIdFilialRotaDestino.filial.idFilial"));

				fo.setSgFilial(parameters.getString("filialRotaByIdFilialRotaOrigem.filial.sgFilial"));
				fd.setSgFilial(parameters.getString("filialRotaByIdFilialRotaDestino.filial.sgFilial"));

				po.setNmFantasia(parameters.getString("filialRotaByIdFilialRotaOrigem.filial.pessoa.nmFantasia"));
				pd.setNmFantasia(parameters.getString("filialRotaByIdFilialRotaDestino.filial.pessoa.nmFantasia"));

				fro.setNrOrdem(parameters.getByte("filialRotaByIdFilialRotaOrigem.nrOrdem"));
				frd.setNrOrdem(parameters.getByte("filialRotaByIdFilialRotaDestino.nrOrdem"));

				triv.setVersao(parameters.getInteger("versao"));

				return triv;
			}
		};

		config.addItemConfig("trechosIda",TrechoRotaIdaVolta.class, itemInit, descComparator);
		config.addItemConfig("trechosVolta",TrechoRotaIdaVolta.class, itemInit, descComparator);

		return config;
	}

	/**
	 * Retorna dados para uma lookup de filial a partir de uma sigla.
	 * 
	 * @author Felipe Ferreira
	 * @param criteria
	 * @return
	 */
	public List findFilialLookup(TypedFlatMap criteria) {
		return filialService.findLookupBySgFilial(criteria.getString("sgFilial"), "");
	}

	/**
	 * find da lookup de filial.
	 * @param criteria
	 * @return List com filiais encontradas.
	 */
	public List findLookupCliente(Map criteria) {
		return clienteService.findLookup(criteria);
	}

	/** 
	 * Verifica se pelo menos um dia da semana foi checado.
	 * @param bean Um objeto.
	 * @return True se pelo menos um dia da semana 
	 * foi checado ou false em caso contrario.
	 */
	public boolean verificaPeloMenosUmDiaChecado(Map parameters) {
		if (((String)parameters.get("blDomingo")).equals("true")
				|| ((String)parameters.get("blSegunda")).equals("true")
				|| ((String)parameters.get("blTerca")).equals("true")
				|| ((String)parameters.get("blQuarta")).equals("true")
				|| ((String)parameters.get("blQuinta")).equals("true")
				|| ((String)parameters.get("blSexta")).equals("true")
				|| ((String)parameters.get("blSabado")).equals("true"))
			return true;
		return false;
	}

	public void setRotaViagemService(RotaViagemService rotaViagemService) {
		super.setMasterService(rotaViagemService);
	}
	private RotaViagemService getRotaViagemService() {
		return (RotaViagemService)super.getMasterService();
	}
	public void setServicoService(ServicoService servicoService) {
		this.servicoService = servicoService;
	}
	public void setServicoRotaViagemService(ServicoRotaViagemService servicoRotaViagemService) {
		this.servicoRotaViagemService = servicoRotaViagemService;
	}
	public void setRotaService(RotaService rotaService) {
		this.rotaService = rotaService;
	}
	public void setTrechoRotaIdaVoltaService(TrechoRotaIdaVoltaService trechoRotaIdaVoltaService) {
		this.trechoRotaIdaVoltaService = trechoRotaIdaVoltaService;
	}
	public void setFilialService(FilialService filialService) {
		this.filialService = filialService;
	}
	public void setFilialRotaService(FilialRotaService filialRotaService) {
		this.filialRotaService = filialRotaService;
	}
	public void setConfiguracoesFacade(ConfiguracoesFacade configuracoesFacade) {
		this.configuracoesFacade = configuracoesFacade;
	}
	public void setTipoMeioTransporteService(TipoMeioTransporteService tipoMeioTransporteService) {
		this.tipoMeioTransporteService = tipoMeioTransporteService;
	}
	public void setClienteService(ClienteService clienteService) {
		this.clienteService = clienteService;
	}
	public void setFluxoFilialService(FluxoFilialService fluxoFilialService) {
		this.fluxoFilialService = fluxoFilialService;
	}
	public void setPontoParadaTrechoService(PontoParadaTrechoService pontoParadaTrechoService) {
		this.pontoParadaTrechoService = pontoParadaTrechoService;
	}
	public void setParametroGeralService(ParametroGeralService parametroGeralService) {
		this.parametroGeralService = parametroGeralService;
	}
}
