package com.mercurio.lms.municipios.action;

import java.io.Serializable;
import java.math.BigDecimal;
import java.util.List;
import java.util.Map;

import org.apache.commons.collections.MapUtils;
import org.apache.commons.lang.StringUtils;

import com.mercurio.adsm.framework.model.CrudAction;
import com.mercurio.adsm.framework.model.ResultSetPage;
import com.mercurio.adsm.framework.util.TypedFlatMap;
import com.mercurio.lms.municipios.model.Rota;
import com.mercurio.lms.municipios.model.service.FilialRotaService;
import com.mercurio.lms.municipios.model.service.FilialService;
import com.mercurio.lms.municipios.model.service.RotaService;

import com.mercurio.adsm.framework.annotations.ParametrizedAttribute;

/**
 * Generated by: ADSM ActionGenerator
 *
 * Não inserir documentação após ou remover a tag do XDoclet a seguir.
 * O valor do <code>id</code> informado abaixo deve ser utilizado para referenciar este serviço.
 * @spring.bean id="lms.municipios.manterRotaAction"
 */

public class ManterRotaAction extends CrudAction {
	private FilialService filialService ;
	private FilialRotaService filialRotaService;

	//monta o map para pesquisar as rotas
	private TypedFlatMap mountFindPaginated(TypedFlatMap criteria) {
		String sgFilialOrigem = criteria.getString("filialOrigem.sgFilial").toUpperCase();
		String sgFilialDestino = criteria.getString("filialDestino.sgFilial").toUpperCase();
		if(StringUtils.isNotBlank(sgFilialDestino)) {
			sgFilialDestino = "%" + sgFilialDestino.toUpperCase();
			sgFilialDestino = sgFilialDestino.substring(0, sgFilialDestino.length() - 1);
		}

		List<Map> filiaisRota = criteria.getList("filialRotas");
		if( (filiaisRota != null) && (!filiaisRota.isEmpty()) ) {
			StringBuilder dsRotaConcatenada = new StringBuilder();
			for(Map filial : filiaisRota) {
				String sgFilial = MapUtils.getString(filial, "filial.sgFilial").toUpperCase();
				dsRotaConcatenada.append(sgFilial).append("-");
			}
			dsRotaConcatenada.deleteCharAt(dsRotaConcatenada.length() - 1);
			criteria.put("dsRotaConcatenada", dsRotaConcatenada.toString());
		}
		criteria.put("filialOrigem", sgFilialOrigem);
		criteria.put("filialDestino", sgFilialDestino);

		return criteria;
	}

	public ResultSetPage findPaginated(TypedFlatMap criteria) {
		return getRotaService().findPaginatedRotasViagem(mountFindPaginated(criteria));
	}
	
	public ResultSetPage findPaginatedRotaViagemEventual(TypedFlatMap criteria) {
		return getRotaService().findPaginatedRotaViagemEventual(mountFindPaginated(criteria));
	}
	
	public Integer getRowCount(TypedFlatMap criteria) {
		return getRotaService().getRowCountRotasViagem(mountFindPaginated(criteria));
	}

	public Integer getRowCountRotaViagemEventual(TypedFlatMap criteria) {
		return getRotaService().getRowCountRotaViagemEventual(mountFindPaginated(criteria));
	}

	/**
	 * Remove uma Rota pelo id passado por parâmetro
	 * @param id Identificador da Rota
	 */
	public void removeById(java.lang.Long id) {
		getRotaService().removeById(id);
	}

	/**
	 * Método sobrescrito para mudar o parâmetro de Object para Rota
	 * Salva o objeto passado por parâmetro
	 * @param bean Rota a ser salvo.
	 * @return Rota salvo
	 */
	public Serializable store(Rota bean) {
		Long idRota = getRotaService().storeRotaViagem(bean.getFilialRotas(),bean.getDsRota());
		if(idRota != null){
			String dsRotaConcatenada = "";
			List filiaisRotas = filialRotaService.findFiliaisRotaByRota(idRota);
			bean.setFilialRotas(filiaisRotas);
			for(int i = 0; i < filiaisRotas.size();i++){
				Map map = (Map)filiaisRotas.get(i);
				dsRotaConcatenada += !dsRotaConcatenada.equals("") ? "-" : "";
				dsRotaConcatenada += ((Map)map.get("filial")).get("sgFilial");
			}
			bean.setIdRota(idRota);
			bean.setDsRota(dsRotaConcatenada);
		}
		return bean;
	}

	/**
	 * Método que remove todos as Rota informados através das Rotas
	 * seus ids.
	 * @param ids Lista de ids das Rota
	 *
	 */
	@ParametrizedAttribute(type = java.lang.Long.class)
	public void removeByIds(List ids) {
		getRotaService().removeByIds(ids);
	}

	/**
	 * Busca um Rota pelo id
	 * @param id Identificador da Rota a ser detalhado
	 * @return Rota encontrado na busca
	 */
	public Rota findById(java.lang.Long id) {
		return getRotaService().findByIdPersonalizado(id);
	}

	public List findFilialLookup(Map criteria){
		return filialService.findLookup(criteria);
	}

	/* retorna o valor do pedagio na data da consulta
	 * parametros obrigatorios: idRota,idTipoMeioTransporte
	 * 
	 */
	public BigDecimal valoresPedagioRota(Long idRota,Long idTipoMeioTransporte, java.sql.Date dataCalculo){
		return valoresPedagioRota(idRota,idTipoMeioTransporte,dataCalculo);
	}

	
	/**
	 * Seta o service para o manter Rota
	 * @param rota Service do manter Rota
	 */
	public void setRotaService(RotaService rotaService) {
		this.defaultService = rotaService;
	}
	private RotaService getRotaService() {
		return (RotaService)this.defaultService;
	}
	public void setFilialRotaService(FilialRotaService filialRotaService) {
		this.filialRotaService = filialRotaService;
	}
	public void setFilialService(FilialService filialService) {
		this.filialService = filialService;
	}

}