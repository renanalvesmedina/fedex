package com.mercurio.lms.contasreceber.action;

import java.io.Serializable;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import com.mercurio.adsm.framework.BusinessException;
import com.mercurio.adsm.framework.annotations.ParametrizedAttribute;
import com.mercurio.adsm.framework.model.CrudAction;
import com.mercurio.adsm.framework.model.DomainValue;
import com.mercurio.adsm.framework.model.service.DomainValueService;
import com.mercurio.adsm.framework.util.TypedFlatMap;
import com.mercurio.lms.configuracoes.ConfiguracoesFacade;
import com.mercurio.lms.contasreceber.model.param.DevedorDocServFatLookupParam;
import com.mercurio.lms.contasreceber.model.param.DivisaoClienteParam;
import com.mercurio.lms.contasreceber.model.service.BloqueioFaturamentoService;
import com.mercurio.lms.contasreceber.model.service.DevedorDocServFatLookUpService;
import com.mercurio.lms.contasreceber.model.service.DevedorDocServFatService;
import com.mercurio.lms.contasreceber.model.service.ManterDevedorDocServFatService;
import com.mercurio.lms.contasreceber.model.service.MotivoTransferenciaService;
import com.mercurio.lms.expedicao.model.DoctoServico;
import com.mercurio.lms.expedicao.model.service.DoctoServicoService;
import com.mercurio.lms.municipios.model.service.FilialService;
import com.mercurio.lms.util.AliasToNestedMapResultTransformer;
import com.mercurio.lms.util.FormatUtils;
import com.mercurio.lms.vendas.model.Cliente;
import com.mercurio.lms.vendas.model.service.ClienteService;
import com.mercurio.lms.vendas.model.service.DivisaoClienteService;

/**
 * Generated by: ADSM ActionGenerator
 *  
 * Não inserir documentação após ou remover a tag do XDoclet a seguir.
 * O valor do <code>id</code> informado abaixo deve ser utilizado para referenciar este serviço.
 * @spring.bean id="lms.contasreceber.manterDevedoresDocumentosServicoAction"
 */

public class ManterDevedoresDocumentosServicoAction extends CrudAction {
	
	private MotivoTransferenciaService motivoTransferenciaService;
	private DomainValueService domainValueService;
	private FilialService filialService;
	private ClienteService clienteService;

	private DoctoServicoService doctoServicoService;
    private DevedorDocServFatLookUpService devedorDocServFatLookUpService;
    private ManterDevedorDocServFatService manterDevedorDocServFatService;
    private ConfiguracoesFacade configuracoesFacade;
    private BloqueioFaturamentoService bloqueioFaturamentoService;
    
    private DivisaoClienteService divisaoClienteService;
	
	private static final int TROCAR  = 0;
	private static final int INCLUIR = 1;
	
	/**
	 * Busca a lista de Motivos de Transferência
	 * @param tfm Critérios de pesquisa
	 * @return Lista de Motivos de Transferência
	 */
	@SuppressWarnings({ "rawtypes", "unchecked" })
	public List findMotivosTransferenciaByCombo(Map map){
		map = new HashMap();
		map.put("tpSituacao","A");
		return motivoTransferenciaService.find(map);
	}
	
	@SuppressWarnings("rawtypes")
	public List validateMonitoramentoEletronicoAutorizado(TypedFlatMap map) {
		Long idDoctoServico  = map.getLong("idDoctoServico");
		if (idDoctoServico != null) {
			doctoServicoService.validateDoctoServicoComMonitoramentoEletronicoAutorizado(idDoctoServico);
		}
		return (List) map.get("data");
	}
	
	/**
	 * Busca os cliente de acordo com o número de identificação informado
	 * @param tfm cliente.pessoa.nrIdentificacao Número de identificação do cliente
	 * @return Lista de clientes
	 */
	@SuppressWarnings({ "rawtypes", "unchecked" })
	public List findClienteByLookup(TypedFlatMap tfm){
			
		List clientes = clienteService.findLookupSimplificado(tfm.getString("pessoa.nrIdentificacao"),null);
		
		List retorno = new ArrayList();
			
		for (Iterator iter = clientes.iterator(); iter.hasNext();) {
				
			Cliente element = (Cliente) iter.next();
				
			TypedFlatMap map = new TypedFlatMap();
			map.put("pessoa.nrIdentificacao",element.getPessoa().getNrIdentificacao());
			map.put("idCliente",element.getIdCliente());
			map.put("pessoa.nmPessoa",element.getPessoa().getNmPessoa());
			map.put("pessoa.nrIdentificacaoFormatado", FormatUtils.formatIdentificacao(element.getPessoa().getTpIdentificacao(),
																					   element.getPessoa().getNrIdentificacao()));
				
			retorno.add(map);
				
		}
			
		return retorno;
			
	}
	
	/**
     * Método que popula a combo de tipos de documento apenas com CTR, CRT, NFS, NFT
     * 
     * @param criteria Critérios de Pesquisa
     * @return List Lista de Tipos de documento
     */
	@SuppressWarnings({ "rawtypes" })
    public List findTipoDocumentoServico(Map criteria) {
		String tpDocFat1 = (String)configuracoesFacade.getValorParametro("TP_DOCTO_FAT6");
		
		String[] dm = tpDocFat1.split(";");
	    
		List dominiosValidos = Arrays.asList(dm);
        
        List retorno = this.domainValueService.findByDomainNameAndValues("DM_TIPO_DOCUMENTO_SERVICO", dominiosValidos);

        return retorno;
    }
    
    /**
     * Busca as filiais para Documento de Serviço Conhecimento
     * @param criteria Critérios de pesquisa (sg_filial)
     * @return Lista de filiais 
     */
	@SuppressWarnings({ "rawtypes", "deprecation" })
    public List findLookupServiceDocumentFilialCTR(Map criteria) {
        return this.filialService.findLookupBySgFilial(criteria);
    }

    /**
     * Busca as filiais para Documento de Serviço Cto Internacional
     * @param criteria Critérios de pesquisa (sg_filial)
     * @return Lista de filiais 
     */
	@SuppressWarnings({ "rawtypes", "deprecation" })
    public List findLookupServiceDocumentFilialCRT(Map criteria) {
        return this.filialService.findLookupBySgFilial(criteria);
    }
    
    /**
     * Busca as filiais para Documento de Serviço Nota Fiscal Serviço
     * @param criteria Critérios de pesquisa (sg_filial)
     * @return Lista de filiais 
     */
	@SuppressWarnings({ "rawtypes", "deprecation" })
    public List findLookupServiceDocumentFilialNFS(Map criteria) {
        return this.filialService.findLookupBySgFilial(criteria);
    }
    
    /**
     * Busca as filial para Documento de Serviço Conhecimento (NFT)
     * @param criteria Critérios de pesquisa (sg_filial)
     * @return Lista de filiais
     */
	@SuppressWarnings({ "rawtypes" })
    public List findLookupServiceDocumentFilialNFT(Map criteria){
    	return findLookupServiceDocumentFilialCTR(criteria);
    }
    
	@SuppressWarnings({ "rawtypes", "deprecation" })
	public List findLookupServiceDocumentFilialNTE(Map criteria) {
		return this.filialService.findLookupBySgFilial(criteria);
	}

	@SuppressWarnings({ "rawtypes", "deprecation" })
	public List findLookupServiceDocumentFilialNSE(Map criteria) {
		return this.filialService.findLookupBySgFilial(criteria);
	}

	@SuppressWarnings({ "rawtypes", "deprecation" })
	public List findLookupServiceDocumentFilialCTE(Map criteria) {
		return this.filialService.findLookupBySgFilial(criteria);
	}

    /**
	 * Retorna a lista de devedores a partir do tipo de documento informado. 
	 * O parametro tpDocumento é obrigatório!
	 * 
	 * @author Edenilson Fornazari
	 * 
	 * @param Long nrDocumento Número do documento informado
	 * @param String tpDocumento Tipo do Documento CTR - CRT - NFS e NFT
	 * @param Long idFilial Identificador da filial de origem associada ao documento de serviço
	 * @return List
	 * 
	 */	
	@SuppressWarnings({ "rawtypes", "unchecked" })
    public List findDevedorServDocFat(TypedFlatMap map){
		DevedorDocServFatLookupParam devedorDocServFatLookupParam = new DevedorDocServFatLookupParam();		
		
		devedorDocServFatLookupParam.setIdFilial(map.getLong("doctoServico.filialByIdFilialOrigem.idFilial"));
		devedorDocServFatLookupParam.setNrDocumentoServico(map.getLong("doctoServico.nrDoctoServico"));
		devedorDocServFatLookupParam.setTpDocumentoServico(map.getString("doctoServico.tpDocumentoServico"));		
		devedorDocServFatLookupParam.setTpSituacaoDevedorDocServFatValido(map.getInteger("tpSituacaoDevedorDocServFatValido"));
		
		List lstRetorno = new ArrayList();
		
		List ret = AliasToNestedMapResultTransformer.getInstance().transformListResult(devedorDocServFatLookUpService.findDevedorDocServFat(devedorDocServFatLookupParam, "LMS-36006"));

		if (ret!=null && ret.size()>0){
			lstRetorno.add(ret.get(0));
		}

		return lstRetorno;    

    }
    
    /**
      * Método que testa se o valor informado no campo VALOR é maior que o valor do documento de serviço.
      * Caso seja, lança a excessão LMS-36024, caso contrário retorna false
      * @param tfm Valores a serem comparados
      * @return <code>false</code> Se o valor informado for menor ou igual ao valor do documento de serviço.
      */
     public Boolean validateValor(TypedFlatMap tfm){
    	 
    	 DoctoServico ds = doctoServicoService.findById(tfm.getLong("idDoctoServico"));
    	 
    	 BigDecimal vlDoctoServico = ds.getVlTotalDocServico().setScale(2, RoundingMode.HALF_UP);
    	 BigDecimal valor		   = tfm.getBigDecimal("valor").setScale(2, RoundingMode.HALF_UP);
    	 
    	 if( valor.compareTo(vlDoctoServico) > 0 ){
    		 throw new BusinessException("LMS-36024");
    	 }
    	 
    	 return Boolean.FALSE;
     }
     
     /**
      * Monta os dados para a listagem 
      * @param tfm Critérios de pesquisa
      * @return ResultSetPage com a lista de DevedorDocServFat encontrada e dados de paginação
      */
     @SuppressWarnings("rawtypes")
     public List findDevedores(TypedFlatMap tfm) {    	 
    	 if (tfm.getLong("devedorDocServFat.idDevedorDocServFat") != null)
    		 bloqueioFaturamentoService.validateByIdDevedorDocServFat(tfm.getLong("devedorDocServFat.idDevedorDocServFat"));
    	 return this.getService().findDevedores(tfm);         
     }
     
     /**
      * Busca o número de Devedores associados ao documento de serviço
      */
     public Integer getRowCount(TypedFlatMap tfm) {
    	return this.getService().getRowCountDevedores(tfm);
     }
	
	/**
	 * Seta a service padrão para a ET Manter Devedores do Documento de Serviço
	 * @param serviceService Service padrão
	 */
	public void setService(DevedorDocServFatService serviceService) {
		this.defaultService = serviceService;
	}
	
	/**
	 * Retorna a Service padrão da ET Manter Devedores do Documento de Serviço
	 * @return DevedorDocServFatService
	 */
	private DevedorDocServFatService getService(){
		return (DevedorDocServFatService) this.defaultService;
	}	

	/**
	 * Remove vários registros de DevedorDocServFat
	 * @param ids Lista de identificadores de DevedorDocServFat
	 *
	 */
	@SuppressWarnings("rawtypes")
	@ParametrizedAttribute(type = java.lang.Long.class)
    public void removeByIds(List ids) {
    	getService().removeByIds(ids);
    }
    
    /**
     * Salva um registro de devedor
     * @param tfm Dados a serem salvos
     * @return Identificador do Devedor salvo
     */
    public Serializable store(TypedFlatMap tfm) {
    	
    	int operacao = tfm.getInteger("operacao").intValue();
    	
    	switch (operacao) {
			case TROCAR :manterDevedorDocServFatService.storeTrocar(tfm);				
						 break;
			
			case INCLUIR:manterDevedorDocServFatService.storeIncluir(tfm);
						 break;
			
			default:break;
		}
    	
    	return null;
    }
    

	
	/**
     * Busca dados do devedor
     * @param id Identificador do Devedor detalhado
     * @return Mapa de dados do detalhamento do Devedor
     */
    @SuppressWarnings({ "rawtypes", "unchecked" })
    public Map findById(java.lang.Long id) {
    	Map	map = getService().findByIdMaped(id);
    	DomainValue tpIdentificacao = (DomainValue)map.get("tpIdentificacao");
		map.put("nrIdentificacaoDevedorAnteriorFormatado",FormatUtils.formatIdentificacao(tpIdentificacao.getValue(),(String)map.get("nrIdentificacaoDevedorAnterior")));
    	
    	return map;
    }
    
	@SuppressWarnings("rawtypes")
	public List findComboDivisaoCliente(TypedFlatMap criteria){
		return this.divisaoClienteService.findByIdClienteMatriz(populateDivisaoClienteParam(criteria));
	}	    
    
	/**
	 * Popula a DivisaoClienteparam para ser usado como filtro na busca por divisao
	 *
	 * @author Hector Julian Esnaola Junior
	 * @since 24/01/2007
	 *
	 * @param tfm
	 * @return
	 *
	 */
	public DivisaoClienteParam populateDivisaoClienteParam(TypedFlatMap tfm){
		
		DivisaoClienteParam dcp = new DivisaoClienteParam();
		
		dcp.setIdCliente(tfm.getLong("idCliente"));
		dcp.setTpSituacao("A");
		dcp.setTpModal(tfm.getString("tpModal"));
		dcp.setTpAbrangencia(tfm.getString("tpAbrangencia"));
		
		return dcp;		
	}
	
    /**
     * Remove um registro de DevedorDocServFat
     * @param id Identificador de DevedorDocServFat
     */
	public void removeById(Long id) {
		manterDevedorDocServFatService.removeById(id);
	}    
    
	public void setMotivoTransferenciaService(MotivoTransferenciaService motivoTransferenciaService) {
		this.motivoTransferenciaService = motivoTransferenciaService;
	}

	public void setDomainValueService(DomainValueService domainValueService) {
		this.domainValueService = domainValueService;
	}

	public void setFilialService(FilialService filialService) {
		this.filialService = filialService;
	}

	public void setClienteService(ClienteService clienteService) {
		this.clienteService = clienteService;
	}

	public void setDoctoServicoService(DoctoServicoService doctoServicoService) {
		this.doctoServicoService = doctoServicoService;
	}

	public void setDevedorDocServFatLookUpService(
			DevedorDocServFatLookUpService devedorDocServFatLookUpService) {
		this.devedorDocServFatLookUpService = devedorDocServFatLookUpService;
	}

	public void setManterDevedorDocServFatService(
			ManterDevedorDocServFatService manterDevedorDocServFatService) {
		this.manterDevedorDocServFatService = manterDevedorDocServFatService;
	}

	public void setDivisaoClienteService(DivisaoClienteService divisaoClienteService) {
		this.divisaoClienteService = divisaoClienteService;
	}

	public void setConfiguracoesFacade(ConfiguracoesFacade configuracoesFacade) {
		this.configuracoesFacade = configuracoesFacade;
	}
	
	public void setBloqueioFaturamentoService(BloqueioFaturamentoService bloqueioFaturamentoService) {
		this.bloqueioFaturamentoService = bloqueioFaturamentoService;
	}
	
	
}
