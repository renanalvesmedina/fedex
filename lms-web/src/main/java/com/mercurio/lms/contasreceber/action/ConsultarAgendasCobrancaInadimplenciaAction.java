package com.mercurio.lms.contasreceber.action;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.joda.time.DateTime;

import com.mercurio.adsm.framework.model.CrudAction;
import com.mercurio.adsm.framework.model.ResultSetPage;
import com.mercurio.adsm.framework.util.TypedFlatMap;
import com.mercurio.lms.configuracoes.model.Usuario;
import com.mercurio.lms.configuracoes.model.service.EnderecoPessoaService;
import com.mercurio.lms.configuracoes.model.service.UsuarioService;
import com.mercurio.lms.contasreceber.model.service.AgendaCobrancaService;
import com.mercurio.lms.util.FormatUtils;
import com.mercurio.lms.util.JTDateTimeUtils;
import com.mercurio.lms.util.session.SessionUtils;
import com.mercurio.lms.vendas.model.service.ClienteService;


/**
 * Generated by: ADSM ActionGenerator
 *  
 * Não inserir documentação após ou remover a tag do XDoclet a seguir.
 * O valor do <code>id</code> informado abaixo deve ser utilizado para referenciar este serviço.
 * @spring.bean id="lms.contasreceber.consultarAgendasCobrancaInadimplenciaAction"
 */

public class ConsultarAgendasCobrancaInadimplenciaAction extends CrudAction {

	private AgendaCobrancaService agendaCobrancaService;
	public void setAgendaCobrancaService(AgendaCobrancaService agendaCobrancaService){
		this.agendaCobrancaService = agendaCobrancaService;
	}
	
	private ClienteService clienteService;
	public void setClienteService(ClienteService clienteService) {
		this.clienteService = clienteService;
	}
	
	private EnderecoPessoaService enderecoPessoaService;
	public void setEnderecoPessoaService(EnderecoPessoaService enderecoPessoaService) {
		this.enderecoPessoaService = enderecoPessoaService;
	}
	
	private UsuarioService usuarioService;
	public void setUsuarioService(UsuarioService usuarioService){
		this.usuarioService = usuarioService;
	}

	/**
     * Método responsável por carregar dados páginados de acordo com os filtros passados
     * @param criteria
     * @return ResultSetPage contendo o resultado do hql.
     */
	public ResultSetPage findPaginatedByAgendaCobranca(TypedFlatMap tfm) throws Exception{
		return agendaCobrancaService.findPaginatedByAgendaCobranca(tfm);
	}
	
	/**
     * Método responsável por fazer a contagem dos registros que retornam do hql para paginação.
     * @param criteria
     * @return Integer contendo o número de registros retornados.
     */
    public Integer getRowCountByAgendaCobranca(TypedFlatMap tfm) throws Exception{
    	return agendaCobrancaService.getRowCountByAgendaCobranca(tfm);
    }
    
    /**
     * CArrega a descrição da agendaCobranca em questão
     * @param idAgendaCobranca
     * @return Map
     */
    public Map findDescricaoAgendaCobranca(TypedFlatMap tfm){
    	Long idAgendaCobranca = tfm.getLong("idAgendaCobranca");
    	return agendaCobrancaService.findDescricaoAgendaCobranca(idAgendaCobranca);
    }
    
    /**
     * Método responsável por buscar clientes de acordo com os filtros passados
     * 
     * @param criteria
     * @return List contendo Clientes
     */
    public List findCliente(TypedFlatMap  criteria){
		List l = clienteService.findClienteByNrIdentificacao(criteria.getString("pessoa.nrIdentificacao"));
		if(!l.isEmpty()) {
			Map cliente = (Map)l.get(0);
			Map pessoa = (Map)cliente.get("pessoa");
			String tpPessoa = (String)((Map)pessoa.get("tpPessoa")).get("value");
			
			//seta o número de identificacao com mascara
			String nrIdentificacao = (String)(pessoa.remove("nrIdentificacao"));
			String tpIdentificacao = (String) ((Map)pessoa.get("tpIdentificacao")).get("value");
			pessoa.put("nrIdentificacao", nrIdentificacao);
			pessoa.put("nrIdentificacaoFormatado", FormatUtils.formatIdentificacao(tpIdentificacao, nrIdentificacao));
			
			Long idCliente = (Long)cliente.get("idCliente");
			cliente.put("municipio", findMunicipioByIdPessoaTpPessoa(tpPessoa, idCliente));
		}
		return l;
	}
    
    /**
     * Método que busca o enderecoPessoa de acordo com tpPessoa e o idPessoa
     * 
     * @param tpPessoa
     * @param idPessoa
     * @return Map com o enderecoPessoa
     */
    private Map findMunicipioByIdPessoaTpPessoa(String tpPessoa, Long idPessoa) {
		String tpEndereco = "COM";
		if("F".equalsIgnoreCase(tpPessoa))
			tpEndereco = "RES";
		return enderecoPessoaService.findMunicipioByIdPessoaTpEndereco(idPessoa, tpEndereco);
	}

    /**
     * Busca a maior e a menor data e hora do dia atual.
     *
     * @author Hector Julian Esnaola Junior
     * @since 01/08/2007
     *
     * @return
     *
     */
    public Map findDateTime(TypedFlatMap tfm){
    	Map map = new HashMap();

    	DateTime dataHoraAtual = JTDateTimeUtils.getDataHoraAtual();
		map.put("dhAgendaCobrancaInicial", JTDateTimeUtils.getFirstHourOfDay(dataHoraAtual));
    	map.put("dhAgendaCobrancaFinal", JTDateTimeUtils.getLastHourOfDay(dataHoraAtual));
    	
    	return map;
    }
    
    /**
     * Busca o id do usario logado 
     * 
     * @author Diego Umpierre
     * 
     * 
     * @return idUsuario logado
     * 
     */
    public Map findUsuarioSessao(){
    	TypedFlatMap map = new TypedFlatMap();
    	Usuario user = SessionUtils.getUsuarioLogado();
    	map.put("idUsuario",user.getIdUsuario());
    	map.put("nrMatricula",user.getNrMatricula());
    	map.put("nmUsuario",user.getNmUsuario());
    	return map;
    }
    
    public List findLookupUsuarioFuncionario(TypedFlatMap tfm){
    	return usuarioService.findLookupUsuarioFuncionario(tfm.getLong("idUsuario"), tfm.getString("nrMatricula"), null, null, null, null, true);
    }
	
	
}
