package com.mercurio.lms.configuracoes.action;

import java.io.Serializable;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.joda.time.YearMonthDay;

import com.mercurio.adsm.core.util.ReflectionUtils;
import com.mercurio.adsm.framework.BusinessException;
import com.mercurio.adsm.framework.annotations.ParametrizedAttribute;
import com.mercurio.adsm.framework.model.ResultSetPage;
import com.mercurio.adsm.framework.model.masterdetail.ItemList;
import com.mercurio.adsm.framework.model.masterdetail.ItemListConfig;
import com.mercurio.adsm.framework.model.masterdetail.MasterDetailAction;
import com.mercurio.adsm.framework.model.masterdetail.MasterDetailFactory;
import com.mercurio.adsm.framework.model.masterdetail.MasterDetailKey;
import com.mercurio.adsm.framework.model.masterdetail.MasterEntry;
import com.mercurio.adsm.framework.model.masterdetail.MasterEntryConfig;
import com.mercurio.adsm.framework.util.TypedFlatMap;
import com.mercurio.lms.configuracoes.model.DistrFreteInternacional;
import com.mercurio.lms.configuracoes.model.Pessoa;
import com.mercurio.lms.configuracoes.model.TramoFreteInternacional;
import com.mercurio.lms.configuracoes.model.service.DistrFreteInternacionalService;
import com.mercurio.lms.municipios.model.service.FilialService;
import com.mercurio.lms.util.JTDateTimeUtils;
import com.mercurio.lms.vendas.model.Cliente;
import com.mercurio.lms.vendas.model.service.ClienteService;

/**
 * Generated by: ADSM ActionGenerator
 *  
 * Não inserir documentação após ou remover a tag do XDoclet a seguir.
 * O valor do <code>id</code> informado abaixo deve ser utilizado para referenciar este serviço.
 * @spring.bean id="lms.configuracoes.manterDistribuicaoFreteInternacionalAction"
 * @author Robson Edemar Gehl
 */

public class ManterDistribuicaoFreteInternacionalAction extends MasterDetailAction {
    
    private ClienteService clienteService;
    private FilialService filialService;

	public DistrFreteInternacionalService getDistrFreteInternacionalService() {
		return (DistrFreteInternacionalService) getMasterService();
	}
	
	public void setDistrFreteInternacionalService(DistrFreteInternacionalService distrFreteInternacionalService) {
		super.setMasterService(distrFreteInternacionalService);
	}
		
	
	public Serializable saveTramo(Map parameters){
        
        Map obj = (Map) parameters.remove("cliente");
        
        Cliente cliente = new Cliente();
        Pessoa pessoa = new Pessoa();
        
        if( !((String)obj.get("idCliente")).equals("") ){
        
            cliente.setIdCliente(Long.valueOf((String)obj.get("idCliente")));
            pessoa.setNmPessoa((String) ((Map)obj.get("pessoa")).get("nmPessoa"));
            
            cliente.setPessoa(pessoa);
            
            cliente.getPessoa().setNrIdentificacao((String) parameters.get("nrIdentificacao"));
            
            parameters.remove("nrIdentificacao");
            
        }
        
        Map parametros = parameters;
        
        if( cliente.getIdCliente() != null ){
            parametros.put("cliente",cliente);
        }
        
		return super.saveItemInstance(parametros, "tramos");
	}
	
	public Object findTramoById(MasterDetailKey key){
		return findItemById(key, "tramos");
	}
	
	public ResultSetPage findPaginated(Map filtros) {
		return super.findPaginated(filtros);
	}
	
	public ResultSetPage findPaginatedTramos(Map parameters){
		return findPaginatedItemList(parameters, "tramos");
	}
	
	public Integer getRowCountTramos(Map parameters){
		return getRowCountItemList(parameters, "tramos");
	}
	
	/**
	 * 
	 *
	 */
    @ParametrizedAttribute(type = java.lang.Long.class)
	public void removeTramoByIds(List list){
		super.removeItemByIds(list, "tramos");
	}
	
	public Serializable store(DistrFreteInternacional distrFreteInternacionalTela){
		
		MasterEntry entry = getMasterFromSession(distrFreteInternacionalTela.getIdDistrFreteInternacional(), true);
		
		DistrFreteInternacional distrFreteInternacional = (DistrFreteInternacional) entry.getMaster();
		
		Set ignore = new HashSet(1);
		ignore.add("versao");
		ReflectionUtils.syncObjectProperties(distrFreteInternacional, distrFreteInternacionalTela, ignore);
		
		ItemList items = getItemsFromSession(entry, "tramos");
		ItemListConfig config = getMasterConfig().getItemListConfig("tramos");
		
		/** REGRA 4.3 */
		validateCruzeChecked(items, distrFreteInternacional.getIdDistrFreteInternacional(), config);
		
		Serializable id = getDistrFreteInternacionalService().store(distrFreteInternacional, items, config);
		items.resetItemsState(); 
    	updateMasterInSession(entry);
		
		return id;
	}
	
	/**
	 * Valida a REGRA 4.3
	 *
	 * @author Hector Julian Esnaola Junior
	 * @since 11/08/2006
	 *
	 * @param items
	 * @param masterId
	 * @param config
	 *
	 */
	public void validateCruzeChecked(ItemList items, Long masterId, ItemListConfig config){
		
		TramoFreteInternacional tramoAnterior = null;
		TramoFreteInternacional tramoAtual;
		
		for (Iterator iter = items.iterator(masterId, config); iter.hasNext();) {
			
			tramoAtual = (TramoFreteInternacional) iter.next();
			
			/** Caso seja a primeira iteração do loop, não deve fazer as validações */
			if(tramoAnterior != null){
				
				/** 
				 * Verifica se o tramoAtual e o tramoAnterior são nulos,
				 * ou se o tramoAtual e o tramoAnterior não são nulos e tem ids iguais
				 */ 
				if((tramoAnterior.getCliente() == null && tramoAtual.getCliente() == null)
						|| (tramoAnterior.getCliente() != null && tramoAtual.getCliente() != null
								&& tramoAnterior.getCliente().getIdCliente().equals(tramoAtual.getCliente().getIdCliente()))){
					
					/** Se ambos tramos estiverem com blCruze == TRUE, será lançada uma excetion */
					if(tramoAnterior.getBlCruze().equals(Boolean.TRUE) && tramoAtual.getBlCruze().equals(Boolean.TRUE))
						throw new BusinessException("LMS-27065");
					
				}
				
			}
			
			tramoAnterior = tramoAtual;
			
		}
		
	}
	
	public Serializable findById(Long id) {
		Serializable master = getDistrFreteInternacionalService().findById(id);
		putMasterInSession(master);
		return master;
	}

	public void removeById(Long id) {
		getDistrFreteInternacionalService().removeById(id);
        newMaster();
	}
	
	/**
	 *
	 */
	@ParametrizedAttribute(type = java.lang.Long.class)
	public void removeByIds(List ids) {
		getDistrFreteInternacionalService().removeByIds(ids);
	}
	
	protected MasterEntryConfig createMasterConfig(MasterDetailFactory masterFactory) {
		
		MasterEntryConfig config = masterFactory.createMasterEntryConfig(DistrFreteInternacional.class);
		
		
		Comparator descComparator = new Comparator() {

			public int compare(Object o1, Object o2) {
				TramoFreteInternacional t1 = (TramoFreteInternacional) o1;
				TramoFreteInternacional t2 = (TramoFreteInternacional) o2;
				
				//Para os dois testes abaixo, sem cliente é menor
				if (t1.getCliente() == null && t2.getCliente() != null){
					return 1;
				}
				
				if (t1.getCliente() != null && t2.getCliente() == null){
					return -1;
				}
				
				//Dois sem cliente, ordena pelo NrTramoFreteInternacional
				if (t1.getCliente() == null && t2.getCliente() == null){
					return t1.getNrTramoFreteInternacional().compareTo(t2.getNrTramoFreteInternacional());
				}
				
				//Quando há cliente, ordena pelo nome da Pessoa
				if (t1.getCliente() != null && t2.getCliente() != null){
					
					int orderByNome = t1.getCliente().getPessoa().getNmPessoa().compareToIgnoreCase(
							t2.getCliente().getPessoa().getNmPessoa());
					
					//Se for a mesma pessoa, então ordena pelo NrTramoFreteInternacional
					if (orderByNome == 0){
						return t1.getNrTramoFreteInternacional().compareTo(t2.getNrTramoFreteInternacional());
					}

					//Ordenação pelo nome do cliente
					return orderByNome;
				}
				return 0;
			}
		
		};
		
		ItemListConfig itemInit = new ItemListConfig() {

            
            
			public List initialize(Long masterId) {
				return getDistrFreteInternacionalService().findTramosFreteInternacionais(masterId);
			}

			public Integer getRowCount(Long masterId) {
				return getDistrFreteInternacionalService().getRowCountdTramosFreteInternacionais(masterId);
			}

			public void modifyItemValues(Object newBean, Object bean) {
				Set ignore = new HashSet(3, 1f);
				ignore.add("idTramoFreteInternacional");
				ignore.add("versao");
				ignore.add("distrFreteInternacional");
				ReflectionUtils.syncObjectProperties(bean, newBean, ignore);
			}

			public Object populateNewItemInstance(Map parameters, Object bean) {
				TramoFreteInternacional tramo = (TramoFreteInternacional) bean;
				ReflectionUtils.copyNestedBean(tramo, parameters);
				resolveDomainValueProperties(tramo);
				ItemList items = getItemsFromSession(getMasterFromSession(getMasterId(parameters), true), "tramos");
				ItemListConfig itensConfig = getMasterConfig().getItemListConfig("tramos");
				
				for (Iterator iter = items.iterator(getMasterId(parameters), itensConfig); iter.hasNext();) {
					TramoFreteInternacional id = (TramoFreteInternacional) iter.next();
					
					/** 
					 * Caso os dois tramos tenham clientes iguais
					 */		
					if (!id.getIdTramoFreteInternacional().equals(tramo.getIdTramoFreteInternacional())
						&& tramo.getCliente() != null && tramo.getCliente().equals(id.getCliente())){
						
						/** 
						 * Dois tramos não podem ter o mesmo cliente e o mesmo nrTramoFreteInternacional, 
						 * caso a regra seja violada, é lançada a excessão 
						 */		
						if(tramo.getNrTramoFreteInternacional().equals(id.getNrTramoFreteInternacional())){
							throw new BusinessException("uniqueConstraintViolated");
						}
							
						/** 
						 * Dois tramos não podem ter o mesmo cliente e blCruze igual true,
						 * caso a regra seja violada, é lançada a excessão 
						 */		
						if(tramo.getBlCruze().equals(Boolean.TRUE) && id.getBlCruze().equals(Boolean.TRUE)){
							throw new BusinessException("LMS-27065");
						}
					
					}
				
					/**
					 * Caso os dois tramos tenham clintes nulos
					 */
					if(!id.getIdTramoFreteInternacional().equals(tramo.getIdTramoFreteInternacional())
							&& tramo.getCliente() == null && id.getCliente() == null){
					
						/** 
						 * Dois tramos não podem ter cliente nulos e o mesmo nrTramoFreteInternacional, 
						 * caso a regra seja violada, é lançada a excessão 
						 */		
						if(tramo.getNrTramoFreteInternacional().equals(id.getNrTramoFreteInternacional())){
							throw new BusinessException("uniqueConstraintViolated");
						}
						
						/** 
						 * Dois tramos não podem ter cliente nulos e blCruze igual true,
						 * caso a regra seja violada, é lançada a excessão 
						 */		
						if(tramo.getBlCruze().equals(Boolean.TRUE) && id.getBlCruze().equals(Boolean.TRUE)){
							throw new BusinessException("LMS-27065");
						}
						
						
					}
					
				}
				
				return tramo;
			}
            
		};
		config.addItemConfig("tramos", TramoFreteInternacional.class, itemInit, descComparator);
		return config;
	}
	
		/**
	 * Busca os cliente de acordo com o número de identificação informado
	 * @param criteria cliente.pessoa.nrIdentificacao Número de identificação do cliente
	 * @return Lista de clientes
	 */
	public List findLookupClientes(TypedFlatMap criteria){
		return clienteService.findLookupSimplificadoAbaCad(
				criteria.getString("pessoa.nrIdentificacao"),
				null,
				criteria.getString("tpSituacao"),
				null);
	}

    /**
     * Busca as Filiais para a lookup de Filiais de acordo com os critérios
     * @param map Critérios de pesquisa
     * @return Lista de Filiais
     */
    public List findLookupFiliaisList(Map map){
        return this.getFilialService().findLookup(map);
    }    
    
    /**
     * Utilizado em todas as lookups de Filial que devem retornar só os vigentes.<BR>     
     * @param criteria Critérios de Pesquisa
     * @return Lista de Filiais vigentes
     */
    public List findLookupBySgFilialVigenteEm(TypedFlatMap map){
        return this.getFilialService().findLookupBySgFilialVigenteEm(map);
    }
    
    /**
     * Busca a data atual
     * @param tfm Critérios de pesquisa
     * @return YearMonthDay Data atual
     */
    public YearMonthDay findDataAtual(TypedFlatMap tfm){
    	return JTDateTimeUtils.getDataAtual();
    }

    /**
     * @return Returns the clienteService.
     */
    public ClienteService getClienteService() {
        return clienteService;
    }

    /**
     * @param clienteService The clienteService to set.
     */
    public void setClienteService(ClienteService clienteService) {
        this.clienteService = clienteService;
    }

    /**
     * @return Returns the filialService.
     */
    public FilialService getFilialService() {
        return filialService;
    }

    /**
     * @param filialService The filialService to set.
     */
    public void setFilialService(FilialService filialService) {
        this.filialService = filialService;
    }
	

}
