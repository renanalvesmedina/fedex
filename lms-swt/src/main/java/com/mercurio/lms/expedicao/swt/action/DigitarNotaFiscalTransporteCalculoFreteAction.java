package com.mercurio.lms.expedicao.swt.action;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import com.mercurio.adsm.framework.BusinessException;
import com.mercurio.adsm.framework.util.TypedFlatMap;
import com.mercurio.lms.expedicao.model.CalculoNFT;
import com.mercurio.lms.expedicao.model.Conhecimento;
import com.mercurio.lms.expedicao.model.ImpostoServico;
import com.mercurio.lms.expedicao.model.ParcelaDoctoServico;
import com.mercurio.lms.expedicao.model.ParcelaServico;
import com.mercurio.lms.expedicao.model.service.NotaFiscalTransporteService;
import com.mercurio.lms.expedicao.report.EmitirNFTService;
import com.mercurio.lms.expedicao.util.ConstantesExpedicao;
import com.mercurio.lms.tabelaprecos.model.ParcelaPreco;
import com.mercurio.lms.vendas.model.DivisaoCliente;

/**
 * Generated by: ADSM ActionGenerator
 *  
 * Não inserir documentação após ou remover a tag do XDoclet a seguir.
 * O valor do <code>id</code> informado abaixo deve ser utilizado para referenciar este serviço.
 * @spring.bean id="lms.expedicao.swt.digitarNotaFiscalTransporteCalculoFreteAction"
 */
public class DigitarNotaFiscalTransporteCalculoFreteAction extends AbstractCalculoFreteAction {
	private NotaFiscalTransporteService notaFiscalTransporteService;
	private EmitirNFTService emitirNFTService;

	/**
	 * Método que chama o serviço para o calculo do frete manual
	 * autor Julio Cesar Fernandes Corrêa
	 * 19/12/2005
	 * @param parameters
	 * @return 
	 */
	public Map executeCalculoManual(TypedFlatMap parameters) {
		Conhecimento conhecimento = (Conhecimento) parameters.get("conhecimento");
		CalculoNFT calculo = (CalculoNFT) parameters.get(ConstantesExpedicao.CALCULO_SERVICO_IN_SESSION);
		calculo = notaFiscalTransporteService.executeCalculoFreteManual(parameters, conhecimento, calculo);
		return montarParcelasCalculo(conhecimento, calculo);
	}

	/**
	 * Esta rotina tem por objetivo chamar as rotinas de cálculo do preço frete 
	 * e dos serviços adicionais, efetuando o cálculo do valor da NFT.
	 * 
	 * @param idDivisaoCliente
	 * @return Parcelas Calculadas
	 */
	public Map executeCalculoFretePrimeiraFase(Map parameters) {
		Long idDivisaoCliente = (Long) parameters.get("idDivisaoCliente");
		Conhecimento conhecimento = (Conhecimento) parameters.get("conhecimento");
		if(idDivisaoCliente != null) {
			DivisaoCliente divisaoCliente = new DivisaoCliente();
			divisaoCliente.setIdDivisaoCliente(idDivisaoCliente);
			conhecimento.setDivisaoCliente(divisaoCliente);
		}

		CalculoNFT calculoNFT = (CalculoNFT) parameters.get(ConstantesExpedicao.CALCULO_SERVICO_IN_SESSION);
		calculoNFT.setIdDivisaoCliente(idDivisaoCliente);
		try {
			notaFiscalTransporteService.executeCalculoFretePrimeiraFase(conhecimento, calculoNFT);			
			parameters.put("conhecimento", conhecimento);
			parameters.put(ConstantesExpedicao.CALCULO_SERVICO_IN_SESSION, calculoNFT);		
		} catch (BusinessException businessException) {
			Map<String, Object> result = new HashMap<String, Object>();
			result.put("conhecimento", conhecimento);
			result.put(ConstantesExpedicao.CALCULO_SERVICO_IN_SESSION, calculoNFT);
			result.put("exception", businessException);
			return result;
		}
		return executeCalculoFreteSegundaFase(parameters);
	}

	/**
	 * Validações pós Calculo do Frete
	 * @return Parcelas Calculadas
	 */
	public Map executeCalculoFreteSegundaFase(Map parameters) {
		Conhecimento conhecimento = (Conhecimento) parameters.get("conhecimento");
		CalculoNFT calculoNFT = (CalculoNFT) parameters.get(ConstantesExpedicao.CALCULO_SERVICO_IN_SESSION);
		notaFiscalTransporteService.executeCalculoFreteSegundaFase(conhecimento, calculoNFT);
		return montarParcelasCalculo(conhecimento, calculoNFT);
	}

	/**
	 * Após o calculo do frete, é necessário montar as parcelas do doctoservico, além de calcular os
	 * subtotais do valor do frete e do valor dos serviços.
	 * 
	 * autor Julio Cesar Fernandes Corrêa
	 * 19/12/2005
	 * @param ds
	 * @param calculo
	 * @return
	 */
	public Map montarParcelasCalculo(Conhecimento conhecimento, CalculoNFT calculoNFT) {
		Map retorno = new HashMap();
		
		if(calculoNFT.getParcelas() != null && calculoNFT.getBlCalculaParcelas().booleanValue()){
			List parcelas = new ArrayList();
			List parcelasDoctoServ = new ArrayList();
			for (Iterator iter = calculoNFT.getParcelas().iterator(); iter.hasNext();) {
				ParcelaServico parcelaServico = (ParcelaServico) iter.next();
				ParcelaPreco parcelaPreco = parcelaServico.getParcelaPreco();
				Map parcela = new HashMap();
				parcela.put("idParcela", parcelaPreco.getIdParcelaPreco());
				parcela.put("vlParcela", parcelaServico.getVlParcela());
				parcela.put("dsParcela", null);
				if (parcelaPreco.getNmParcelaPreco() != null) {
					parcela.put("dsParcela", parcelaPreco.getNmParcelaPreco().getValue());
				}
				parcelas.add(parcela);
				parcelasDoctoServ.add(new ParcelaDoctoServico(parcelaServico.getVlBrutoParcela(), parcelaServico.getVlParcela(), parcelaPreco, conhecimento));
			}
			conhecimento.setParcelaDoctoServicos(parcelasDoctoServ);
			retorno.put("parcelasFrete", parcelas);
		} else {
			conhecimento.setParcelaDoctoServicos(null);
		}
		if(calculoNFT.getTributos() != null ) {
			List tributos = new ArrayList();
			for(Iterator it = calculoNFT.getTributos().iterator(); it.hasNext();){
				ImpostoServico impostoServico = (ImpostoServico)it.next();
				impostoServico.setConhecimento(conhecimento);
				Map tributo = new HashMap();
				tributo.put("nome", impostoServico.getTpImposto().getDescription().toString());
				tributo.put("valor",impostoServico.getVlImposto());
				tributos.add(tributo);
			}
			conhecimento.setImpostoServicos(calculoNFT.getTributos());
			retorno.put("tributos", tributos);
		} else {
			conhecimento.setImpostoServicos(null);
		}
		retorno.put("vlTotalTributo", calculoNFT.getVlTotalTributos());
		retorno.put("vlTotalFrete", calculoNFT.getVlTotalParcelas());
		retorno.put("vlTotalNota", calculoNFT.getVlTotal());
		retorno.put("vlDesconto", calculoNFT.getVlDesconto());
		retorno.put("conhecimento", conhecimento);
		retorno.put(ConstantesExpedicao.CALCULO_SERVICO_IN_SESSION, calculoNFT);
		return retorno;
	}

	public Serializable gravaNotaPrimeiraFase(Map parameters) {
		
		HashMap retorno = null;

		try {
			retorno = notaFiscalTransporteService.validateExistenciaPCE((Conhecimento) parameters.get("conhecimento"));
		} catch (BusinessException e) {
			String key = e.getMessageKey();
			if("LMS-01097".equals(key)) {
				retorno = new HashMap<String, Object>();
				retorno.put("idVersaoDescritivoPce", e.getMessageArguments()[0]);
			} else throw e;
		}
		
		if(retorno == null) {
			return gravaNotaSegundaFase(parameters);
		}
		return retorno;
	}

	public Serializable gravaNotaSegundaFase(Map parameters) {
		Conhecimento conhecimento = (Conhecimento) parameters.get("conhecimento");
		String nft = emitirNFTService.storeAndPrint(conhecimento, (Long) parameters.get("nrProximoFormulario"), (String) parameters.get("dsMacAddress"));

		HashMap retorno = new HashMap();
		retorno.put("nft", nft);
		retorno.put("idConhecimento", conhecimento.getIdDoctoServico());
		return retorno;
	}
	
	public Map<String, Object> findTpClienteInSession(Map parameters) {
		Map<String, Object> result = new HashMap<String, Object>();
		CalculoNFT calculoNFT = (CalculoNFT) parameters.get(ConstantesExpedicao.CALCULO_SERVICO_IN_SESSION);
		result.put("tpCliente", calculoNFT.getClienteBase().getTpCliente().getValue());
		return result;
	}
	
	public Map findDivisaoClienteByCTRC(Map parameters) {
		List list = findDivisaoCliente(parameters);
		if (list == null) {
			return parameters;
		} else {
			parameters.put("listDivisao", list);
		}
		return parameters;		
	}
	
	/*
	 * GETTERS E SETTERS
	 */
	public void setNotaFiscalTransporteService(NotaFiscalTransporteService notaFiscalTransporteService) {
		this.notaFiscalTransporteService = notaFiscalTransporteService;
	}

	public void setEmitirNFTService(EmitirNFTService emitirNFTService) {
		this.emitirNFTService = emitirNFTService;
	}
}
